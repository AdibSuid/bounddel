"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/polygon-clipping";
exports.ids = ["vendor-chunks/polygon-clipping"];
exports.modules = {

/***/ "(ssr)/./node_modules/polygon-clipping/dist/polygon-clipping.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/polygon-clipping/dist/polygon-clipping.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var splaytree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! splaytree */ \"(ssr)/./node_modules/splaytree/dist/splay.esm.js\");\n/* harmony import */ var robust_predicates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! robust-predicates */ \"(ssr)/./node_modules/robust-predicates/index.js\");\n\n\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\n\nconst isInBbox = (bbox, point) => {\n  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n};\n\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\nconst getBboxOverlap = (b1, b2) => {\n  // check if the bboxes overlap at all\n  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;\n\n  // find the middle two X values\n  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;\n\n  // find the middle two Y values\n  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;\n\n  // put those middle values together to get the overlap\n  return {\n    ll: {\n      x: lowerX,\n      y: lowerY\n    },\n    ur: {\n      x: upperX,\n      y: upperY\n    }\n  };\n};\n\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\n\nlet epsilon = Number.EPSILON;\n\n// IE Polyfill\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\nconst EPSILON_SQ = epsilon * epsilon;\n\n/* FLP comparator */\nconst cmp = (a, b) => {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0;\n    }\n  }\n\n  // check if they're flp equal\n  const ab = a - b;\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0;\n  }\n\n  // normal comparison\n  return a < b ? -1 : 1;\n};\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nclass PtRounder {\n  constructor() {\n    this.reset();\n  }\n  reset() {\n    this.xRounder = new CoordRounder();\n    this.yRounder = new CoordRounder();\n  }\n  round(x, y) {\n    return {\n      x: this.xRounder.round(x),\n      y: this.yRounder.round(y)\n    };\n  }\n}\nclass CoordRounder {\n  constructor() {\n    this.tree = new splaytree__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    // preseed with 0 so we don't end up with values < Number.EPSILON\n    this.round(0);\n  }\n\n  // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n  round(coord) {\n    const node = this.tree.add(coord);\n    const prevNode = this.tree.prev(node);\n    if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n      this.tree.remove(coord);\n      return prevNode.key;\n    }\n    const nextNode = this.tree.next(node);\n    if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n      this.tree.remove(coord);\n      return nextNode.key;\n    }\n    return coord;\n  }\n}\n\n// singleton available by import\nconst rounder = new PtRounder();\n\n/* Cross Product of two vectors with first point at origin */\nconst crossProduct = (a, b) => a.x * b.y - a.y * b.x;\n\n/* Dot Product of two vectors with first point at origin */\nconst dotProduct = (a, b) => a.x * b.x + a.y * b.y;\n\n/* Comparator for two vectors with same starting point */\nconst compareVectorAngles = (basePt, endPt1, endPt2) => {\n  const res = (0,robust_predicates__WEBPACK_IMPORTED_MODULE_1__.orient2d)(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);\n  if (res > 0) return -1;\n  if (res < 0) return 1;\n  return 0;\n};\nconst length = v => Math.sqrt(dotProduct(v, v));\n\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\nconst sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  const vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\nconst cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  const vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst horizontalIntersection = (pt, v, y) => {\n  if (v.y === 0) return null;\n  return {\n    x: pt.x + v.x / v.y * (y - pt.y),\n    y: y\n  };\n};\n\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst verticalIntersection = (pt, v, x) => {\n  if (v.x === 0) return null;\n  return {\n    x: x,\n    y: pt.y + v.y / v.x * (x - pt.x)\n  };\n};\n\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst intersection$1 = (pt1, v1, pt2, v2) => {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);\n\n  // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  const kross = crossProduct(v1, v2);\n  if (kross == 0) return null;\n  const ve = {\n    x: pt2.x - pt1.x,\n    y: pt2.y - pt1.y\n  };\n  const d1 = crossProduct(ve, v1) / kross;\n  const d2 = crossProduct(ve, v2) / kross;\n\n  // take the average of the two calculations to minimize rounding error\n  const x1 = pt1.x + d2 * v1.x,\n    x2 = pt2.x + d1 * v2.x;\n  const y1 = pt1.y + d2 * v1.y,\n    y2 = pt2.y + d1 * v2.y;\n  const x = (x1 + x2) / 2;\n  const y = (y1 + y2) / 2;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nclass SweepEvent {\n  // for ordering sweep events in the sweep event queue\n  static compare(a, b) {\n    // favor event with a point that the sweep line hits first\n    const ptCmp = SweepEvent.comparePoints(a.point, b.point);\n    if (ptCmp !== 0) return ptCmp;\n\n    // the points are the same, so link them if needed\n    if (a.point !== b.point) a.link(b);\n\n    // favor right events over left\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n\n    // we have two matching left or right endpoints\n    // ordering of this case is the same as for their segments\n    return Segment.compare(a.segment, b.segment);\n  }\n\n  // for ordering points in sweep line order\n  static comparePoints(aPt, bPt) {\n    if (aPt.x < bPt.x) return -1;\n    if (aPt.x > bPt.x) return 1;\n    if (aPt.y < bPt.y) return -1;\n    if (aPt.y > bPt.y) return 1;\n    return 0;\n  }\n\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor(point, isLeft) {\n    if (point.events === undefined) point.events = [this];else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft;\n    // this.segment, this.otherSE set by factory\n  }\n  link(other) {\n    if (other.point === this.point) {\n      throw new Error(\"Tried to link already linked events\");\n    }\n    const otherEvents = other.point.events;\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i];\n      this.point.events.push(evt);\n      evt.point = this.point;\n    }\n    this.checkForConsuming();\n  }\n\n  /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */\n  checkForConsuming() {\n    // FIXME: The loops in this method run O(n^2) => no good.\n    //        Maintain little ordered sweep event trees?\n    //        Can we maintaining an ordering that avoids the need\n    //        for the re-sorting with getLeftmostComparator in geom-out?\n\n    // Compare each pair of events to see if other events also match\n    const numEvents = this.point.events.length;\n    for (let i = 0; i < numEvents; i++) {\n      const evt1 = this.point.events[i];\n      if (evt1.segment.consumedBy !== undefined) continue;\n      for (let j = i + 1; j < numEvents; j++) {\n        const evt2 = this.point.events[j];\n        if (evt2.consumedBy !== undefined) continue;\n        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n        evt1.segment.consume(evt2.segment);\n      }\n    }\n  }\n  getAvailableLinkedEvents() {\n    // point.events is always of length 2 or greater\n    const events = [];\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i];\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt);\n      }\n    }\n    return events;\n  }\n\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator(baseEvent) {\n    const cache = new Map();\n    const fillCache = linkedEvent => {\n      const nextEvent = linkedEvent.otherSE;\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n      });\n    };\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a);\n      if (!cache.has(b)) fillCache(b);\n      const {\n        sine: asine,\n        cosine: acosine\n      } = cache.get(a);\n      const {\n        sine: bsine,\n        cosine: bcosine\n      } = cache.get(b);\n\n      // both on or above x-axis\n      if (asine >= 0 && bsine >= 0) {\n        if (acosine < bcosine) return 1;\n        if (acosine > bcosine) return -1;\n        return 0;\n      }\n\n      // both below x-axis\n      if (asine < 0 && bsine < 0) {\n        if (acosine < bcosine) return -1;\n        if (acosine > bcosine) return 1;\n        return 0;\n      }\n\n      // one above x-axis, one below\n      if (bsine < asine) return -1;\n      if (bsine > asine) return 1;\n      return 0;\n    };\n  }\n}\n\n// Give segments unique ID's to get consistent sorting of\n// segments and sweep events when all else is identical\nlet segmentId = 0;\nclass Segment {\n  /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */\n  static compare(a, b) {\n    const alx = a.leftSE.point.x;\n    const blx = b.leftSE.point.x;\n    const arx = a.rightSE.point.x;\n    const brx = b.rightSE.point.x;\n\n    // check if they're even in the same vertical plane\n    if (brx < alx) return 1;\n    if (arx < blx) return -1;\n    const aly = a.leftSE.point.y;\n    const bly = b.leftSE.point.y;\n    const ary = a.rightSE.point.y;\n    const bry = b.rightSE.point.y;\n\n    // is left endpoint of segment B the right-more?\n    if (alx < blx) {\n      // are the two segments in the same horizontal plane?\n      if (bly < aly && bly < ary) return 1;\n      if (bly > aly && bly > ary) return -1;\n\n      // is the B left endpoint colinear to segment A?\n      const aCmpBLeft = a.comparePoint(b.leftSE.point);\n      if (aCmpBLeft < 0) return 1;\n      if (aCmpBLeft > 0) return -1;\n\n      // is the A right endpoint colinear to segment B ?\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return -1;\n    }\n\n    // is left endpoint of segment A the right-more?\n    if (alx > blx) {\n      if (aly < bly && aly < bry) return -1;\n      if (aly > bly && aly > bry) return 1;\n\n      // is the A left endpoint colinear to segment B?\n      const bCmpALeft = b.comparePoint(a.leftSE.point);\n      if (bCmpALeft !== 0) return bCmpALeft;\n\n      // is the B right endpoint colinear to segment A?\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return 1;\n    }\n\n    // if we get here, the two left endpoints are in the same\n    // vertical plane, ie alx === blx\n\n    // consider the lower left-endpoint to come first\n    if (aly < bly) return -1;\n    if (aly > bly) return 1;\n\n    // left endpoints are identical\n    // check for colinearity by using the left-more right endpoint\n\n    // is the A right endpoint more left-more?\n    if (arx < brx) {\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n    }\n\n    // is the B right endpoint more left-more?\n    if (arx > brx) {\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n    }\n    if (arx !== brx) {\n      // are these two [almost] vertical segments with opposite orientation?\n      // if so, the one with the lower right endpoint comes first\n      const ay = ary - aly;\n      const ax = arx - alx;\n      const by = bry - bly;\n      const bx = brx - blx;\n      if (ay > ax && by < bx) return 1;\n      if (ay < ax && by > bx) return -1;\n    }\n\n    // we have colinear segments with matching orientation\n    // consider the one with more left-more right endpoint to be first\n    if (arx > brx) return 1;\n    if (arx < brx) return -1;\n\n    // if we get here, two two right endpoints are in the same\n    // vertical plane, ie arx === brx\n\n    // consider the lower right-endpoint to come first\n    if (ary < bry) return -1;\n    if (ary > bry) return 1;\n\n    // right endpoints identical as well, so the segments are idential\n    // fall back on creation order as consistent tie-breaker\n    if (a.id < b.id) return -1;\n    if (a.id > b.id) return 1;\n\n    // identical segment, ie a === b\n    return 0;\n  }\n\n  /* Warning: a reference to ringWindings input will be stored,\n   *  and possibly will be later modified */\n  constructor(leftSE, rightSE, rings, windings) {\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings;\n    // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n  static fromRing(pt1, pt2, ring) {\n    let leftPt, rightPt, winding;\n\n    // ordering the two points according to sweep line ordering\n    const cmpPts = SweepEvent.comparePoints(pt1, pt2);\n    if (cmpPts < 0) {\n      leftPt = pt1;\n      rightPt = pt2;\n      winding = 1;\n    } else if (cmpPts > 0) {\n      leftPt = pt2;\n      rightPt = pt1;\n      winding = -1;\n    } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);\n    const leftSE = new SweepEvent(leftPt, true);\n    const rightSE = new SweepEvent(rightPt, false);\n    return new Segment(leftSE, rightSE, [ring], [winding]);\n  }\n\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE(newRightSE) {\n    this.rightSE = newRightSE;\n    this.rightSE.segment = this;\n    this.rightSE.otherSE = this.leftSE;\n    this.leftSE.otherSE = this.rightSE;\n  }\n  bbox() {\n    const y1 = this.leftSE.point.y;\n    const y2 = this.rightSE.point.y;\n    return {\n      ll: {\n        x: this.leftSE.point.x,\n        y: y1 < y2 ? y1 : y2\n      },\n      ur: {\n        x: this.rightSE.point.x,\n        y: y1 > y2 ? y1 : y2\n      }\n    };\n  }\n\n  /* A vector from the left point to the right */\n  vector() {\n    return {\n      x: this.rightSE.point.x - this.leftSE.point.x,\n      y: this.rightSE.point.y - this.leftSE.point.y\n    };\n  }\n  isAnEndpoint(pt) {\n    return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n  }\n\n  /* Compare this segment with a point.\n   *\n   * A point P is considered to be colinear to a segment if there\n   * exists a distance D such that if we travel along the segment\n   * from one * endpoint towards the other a distance D, we find\n   * ourselves at point P.\n   *\n   * Return value indicates:\n   *\n   *   1: point lies above the segment (to the left of vertical)\n   *   0: point is colinear to segment\n   *  -1: point lies below the segment (to the right of vertical)\n   */\n  comparePoint(point) {\n    if (this.isAnEndpoint(point)) return 0;\n    const lPt = this.leftSE.point;\n    const rPt = this.rightSE.point;\n    const v = this.vector();\n\n    // Exactly vertical segments.\n    if (lPt.x === rPt.x) {\n      if (point.x === lPt.x) return 0;\n      return point.x < lPt.x ? 1 : -1;\n    }\n\n    // Nearly vertical segments with an intersection.\n    // Check to see where a point on the line with matching Y coordinate is.\n    const yDist = (point.y - lPt.y) / v.y;\n    const xFromYDist = lPt.x + yDist * v.x;\n    if (point.x === xFromYDist) return 0;\n\n    // General case.\n    // Check to see where a point on the line with matching X coordinate is.\n    const xDist = (point.x - lPt.x) / v.x;\n    const yFromXDist = lPt.y + xDist * v.y;\n    if (point.y === yFromXDist) return 0;\n    return point.y < yFromXDist ? -1 : 1;\n  }\n\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection(other) {\n    // If bboxes don't overlap, there can't be any intersections\n    const tBbox = this.bbox();\n    const oBbox = other.bbox();\n    const bboxOverlap = getBboxOverlap(tBbox, oBbox);\n    if (bboxOverlap === null) return null;\n\n    // We first check to see if the endpoints can be considered intersections.\n    // This will 'snap' intersections to endpoints if possible, and will\n    // handle cases of colinearity.\n\n    const tlp = this.leftSE.point;\n    const trp = this.rightSE.point;\n    const olp = other.leftSE.point;\n    const orp = other.rightSE.point;\n\n    // does each endpoint touch the other segment?\n    // note that we restrict the 'touching' definition to only allow segments\n    // to touch endpoints that lie forward from where we are in the sweep line pass\n    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;\n\n    // do left endpoints match?\n    if (touchesThisLSE && touchesOtherLSE) {\n      // these two cases are for colinear segments with matching left\n      // endpoints, and one segment being longer than the other\n      if (touchesThisRSE && !touchesOtherRSE) return trp;\n      if (!touchesThisRSE && touchesOtherRSE) return orp;\n      // either the two segments match exactly (two trival intersections)\n      // or just on their left endpoint (one trivial intersection\n      return null;\n    }\n\n    // does this left endpoint matches (other doesn't)\n    if (touchesThisLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesOtherRSE) {\n        if (tlp.x === orp.x && tlp.y === orp.y) return null;\n      }\n      // t-intersection on left endpoint\n      return tlp;\n    }\n\n    // does other left endpoint matches (this doesn't)\n    if (touchesOtherLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesThisRSE) {\n        if (trp.x === olp.x && trp.y === olp.y) return null;\n      }\n      // t-intersection on left endpoint\n      return olp;\n    }\n\n    // trivial intersection on right endpoints\n    if (touchesThisRSE && touchesOtherRSE) return null;\n\n    // t-intersections on just one right endpoint\n    if (touchesThisRSE) return trp;\n    if (touchesOtherRSE) return orp;\n\n    // None of our endpoints intersect. Look for a general intersection between\n    // infinite lines laid over the segments\n    const pt = intersection$1(tlp, this.vector(), olp, other.vector());\n\n    // are the segments parrallel? Note that if they were colinear with overlap,\n    // they would have an endpoint intersection and that case was already handled above\n    if (pt === null) return null;\n\n    // is the intersection found between the lines not on the segments?\n    if (!isInBbox(bboxOverlap, pt)) return null;\n\n    // round the the computed point if needed\n    return rounder.round(pt.x, pt.y);\n  }\n\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split(point) {\n    const newEvents = [];\n    const alreadyLinked = point.events !== undefined;\n    const newLeftSE = new SweepEvent(point, true);\n    const newRightSE = new SweepEvent(point, false);\n    const oldRightSE = this.rightSE;\n    this.replaceRightSE(newRightSE);\n    newEvents.push(newRightSE);\n    newEvents.push(newLeftSE);\n    const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());\n\n    // when splitting a nearly vertical downward-facing segment,\n    // sometimes one of the resulting new segments is vertical, in which\n    // case its left and right events may need to be swapped\n    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n      newSeg.swapEvents();\n    }\n    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n      this.swapEvents();\n    }\n\n    // in the point we just used to create new sweep events with was already\n    // linked to other events, we need to check if either of the affected\n    // segments should be consumed\n    if (alreadyLinked) {\n      newLeftSE.checkForConsuming();\n      newRightSE.checkForConsuming();\n    }\n    return newEvents;\n  }\n\n  /* Swap which event is left and right */\n  swapEvents() {\n    const tmpEvt = this.rightSE;\n    this.rightSE = this.leftSE;\n    this.leftSE = tmpEvt;\n    this.leftSE.isLeft = true;\n    this.rightSE.isLeft = false;\n    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n      this.windings[i] *= -1;\n    }\n  }\n\n  /* Consume another segment. We take their rings under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume(other) {\n    let consumer = this;\n    let consumee = other;\n    while (consumer.consumedBy) consumer = consumer.consumedBy;\n    while (consumee.consumedBy) consumee = consumee.consumedBy;\n    const cmp = Segment.compare(consumer, consumee);\n    if (cmp === 0) return; // already consumed\n    // the winner of the consumption is the earlier segment\n    // according to sweep line ordering\n    if (cmp > 0) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n\n    // make sure a segment doesn't consume it's prev\n    if (consumer.prev === consumee) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n      const ring = consumee.rings[i];\n      const winding = consumee.windings[i];\n      const index = consumer.rings.indexOf(ring);\n      if (index === -1) {\n        consumer.rings.push(ring);\n        consumer.windings.push(winding);\n      } else consumer.windings[index] += winding;\n    }\n    consumee.rings = null;\n    consumee.windings = null;\n    consumee.consumedBy = consumer;\n\n    // mark sweep events consumed as to maintain ordering in sweep event queue\n    consumee.leftSE.consumedBy = consumer.leftSE;\n    consumee.rightSE.consumedBy = consumer.rightSE;\n  }\n\n  /* The first segment previous segment chain that is in the result */\n  prevInResult() {\n    if (this._prevInResult !== undefined) return this._prevInResult;\n    if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n    return this._prevInResult;\n  }\n  beforeState() {\n    if (this._beforeState !== undefined) return this._beforeState;\n    if (!this.prev) this._beforeState = {\n      rings: [],\n      windings: [],\n      multiPolys: []\n    };else {\n      const seg = this.prev.consumedBy || this.prev;\n      this._beforeState = seg.afterState();\n    }\n    return this._beforeState;\n  }\n  afterState() {\n    if (this._afterState !== undefined) return this._afterState;\n    const beforeState = this.beforeState();\n    this._afterState = {\n      rings: beforeState.rings.slice(0),\n      windings: beforeState.windings.slice(0),\n      multiPolys: []\n    };\n    const ringsAfter = this._afterState.rings;\n    const windingsAfter = this._afterState.windings;\n    const mpsAfter = this._afterState.multiPolys;\n\n    // calculate ringsAfter, windingsAfter\n    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n      const ring = this.rings[i];\n      const winding = this.windings[i];\n      const index = ringsAfter.indexOf(ring);\n      if (index === -1) {\n        ringsAfter.push(ring);\n        windingsAfter.push(winding);\n      } else windingsAfter[index] += winding;\n    }\n\n    // calcualte polysAfter\n    const polysAfter = [];\n    const polysExclude = [];\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      if (windingsAfter[i] === 0) continue; // non-zero rule\n      const ring = ringsAfter[i];\n      const poly = ring.poly;\n      if (polysExclude.indexOf(poly) !== -1) continue;\n      if (ring.isExterior) polysAfter.push(poly);else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n        const index = polysAfter.indexOf(ring.poly);\n        if (index !== -1) polysAfter.splice(index, 1);\n      }\n    }\n\n    // calculate multiPolysAfter\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly;\n      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n    }\n    return this._afterState;\n  }\n\n  /* Is this segment part of the final result? */\n  isInResult() {\n    // if we've been consumed, we're not in the result\n    if (this.consumedBy) return false;\n    if (this._isInResult !== undefined) return this._isInResult;\n    const mpsBefore = this.beforeState().multiPolys;\n    const mpsAfter = this.afterState().multiPolys;\n    switch (operation.type) {\n      case \"union\":\n        {\n          // UNION - included iff:\n          //  * On one side of us there is 0 poly interiors AND\n          //  * On the other side there is 1 or more.\n          const noBefores = mpsBefore.length === 0;\n          const noAfters = mpsAfter.length === 0;\n          this._isInResult = noBefores !== noAfters;\n          break;\n        }\n      case \"intersection\":\n        {\n          // INTERSECTION - included iff:\n          //  * on one side of us all multipolys are rep. with poly interiors AND\n          //  * on the other side of us, not all multipolys are repsented\n          //    with poly interiors\n          let least;\n          let most;\n          if (mpsBefore.length < mpsAfter.length) {\n            least = mpsBefore.length;\n            most = mpsAfter.length;\n          } else {\n            least = mpsAfter.length;\n            most = mpsBefore.length;\n          }\n          this._isInResult = most === operation.numMultiPolys && least < most;\n          break;\n        }\n      case \"xor\":\n        {\n          // XOR - included iff:\n          //  * the difference between the number of multipolys represented\n          //    with poly interiors on our two sides is an odd number\n          const diff = Math.abs(mpsBefore.length - mpsAfter.length);\n          this._isInResult = diff % 2 === 1;\n          break;\n        }\n      case \"difference\":\n        {\n          // DIFFERENCE included iff:\n          //  * on exactly one side, we have just the subject\n          const isJustSubject = mps => mps.length === 1 && mps[0].isSubject;\n          this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n          break;\n        }\n      default:\n        throw new Error(`Unrecognized operation type found ${operation.type}`);\n    }\n    return this._isInResult;\n  }\n}\n\nclass RingIn {\n  constructor(geomRing, poly, isExterior) {\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n    if (typeof geomRing[0][0] !== \"number\" || typeof geomRing[0][1] !== \"number\") {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n    this.bbox = {\n      ll: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      },\n      ur: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      }\n    };\n    let prevPoint = firstPoint;\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== \"number\" || typeof geomRing[i][1] !== \"number\") {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      }\n      let point = rounder.round(geomRing[i][0], geomRing[i][1]);\n      // skip repeated points\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    }\n    // add segment from last to first if last is not the same as first\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i];\n      sweepEvents.push(segment.leftSE);\n      sweepEvents.push(segment.rightSE);\n    }\n    return sweepEvents;\n  }\n}\nclass PolyIn {\n  constructor(geomPoly, multiPoly) {\n    if (!Array.isArray(geomPoly)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.exteriorRing = new RingIn(geomPoly[0], this, true);\n    // copy by value\n    this.bbox = {\n      ll: {\n        x: this.exteriorRing.bbox.ll.x,\n        y: this.exteriorRing.bbox.ll.y\n      },\n      ur: {\n        x: this.exteriorRing.bbox.ur.x,\n        y: this.exteriorRing.bbox.ur.y\n      }\n    };\n    this.interiorRings = [];\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      const ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n    this.multiPoly = multiPoly;\n  }\n  getSweepEvents() {\n    const sweepEvents = this.exteriorRing.getSweepEvents();\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents();\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n}\nclass MultiPolyIn {\n  constructor(geom, isSubject) {\n    if (!Array.isArray(geom)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === \"number\") geom = [geom];\n    } catch (ex) {\n      // The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n    this.polys = [];\n    this.bbox = {\n      ll: {\n        x: Number.POSITIVE_INFINITY,\n        y: Number.POSITIVE_INFINITY\n      },\n      ur: {\n        x: Number.NEGATIVE_INFINITY,\n        y: Number.NEGATIVE_INFINITY\n      }\n    };\n    for (let i = 0, iMax = geom.length; i < iMax; i++) {\n      const poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n    this.isSubject = isSubject;\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents();\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n}\n\nclass RingOut {\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory(allSegments) {\n    const ringsOut = [];\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i];\n      if (!segment.isInResult() || segment.ringOut) continue;\n      let prevEvent = null;\n      let event = segment.leftSE;\n      let nextEvent = segment.rightSE;\n      const events = [event];\n      const startingPoint = event.point;\n      const intersectionLEs = [];\n\n      /* Walk the chain of linked events to form a closed ring */\n      while (true) {\n        prevEvent = event;\n        event = nextEvent;\n        events.push(event);\n\n        /* Is the ring complete? */\n        if (event.point === startingPoint) break;\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents();\n\n          /* Did we hit a dead end? This shouldn't happen.\n           * Indicates some earlier part of the algorithm malfunctioned. */\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point;\n            const lastPt = events[events.length - 1].point;\n            throw new Error(`Unable to complete output ring starting at [${firstPt.x},` + ` ${firstPt.y}]. Last matching segment found ends at` + ` [${lastPt.x}, ${lastPt.y}].`);\n          }\n\n          /* Only one way to go, so cotinue on the path */\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE;\n            break;\n          }\n\n          /* We must have an intersection. Check for a completed loop */\n          let indexLE = null;\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j;\n              break;\n            }\n          }\n          /* Found a completed loop. Cut that off and make a ring */\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0];\n            const ringEvents = events.splice(intersectionLE.index);\n            ringEvents.unshift(ringEvents[0].otherSE);\n            ringsOut.push(new RingOut(ringEvents.reverse()));\n            continue;\n          }\n          /* register the intersection */\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point\n          });\n          /* Choose the left-most option to continue the walk */\n          const comparator = event.getLeftmostComparator(prevEvent);\n          nextEvent = availableLEs.sort(comparator)[0].otherSE;\n          break;\n        }\n      }\n      ringsOut.push(new RingOut(events));\n    }\n    return ringsOut;\n  }\n  constructor(events) {\n    this.events = events;\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n    this.poly = null;\n  }\n  getGeom() {\n    // Remove superfluous points (ie extra points along a straight line),\n    let prevPt = this.events[0].point;\n    const points = [prevPt];\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt = this.events[i].point;\n      const nextPt = this.events[i + 1].point;\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue;\n      points.push(pt);\n      prevPt = pt;\n    }\n\n    // ring was all (within rounding error of angle calc) colinear points\n    if (points.length === 1) return null;\n\n    // check if the starting point is necessary\n    const pt = points[0];\n    const nextPt = points[1];\n    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n    points.push(points[0]);\n    const step = this.isExteriorRing() ? 1 : -1;\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1;\n    const iEnd = this.isExteriorRing() ? points.length : -1;\n    const orderedPoints = [];\n    for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y]);\n    return orderedPoints;\n  }\n  isExteriorRing() {\n    if (this._isExteriorRing === undefined) {\n      const enclosing = this.enclosingRing();\n      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n    }\n    return this._isExteriorRing;\n  }\n  enclosingRing() {\n    if (this._enclosingRing === undefined) {\n      this._enclosingRing = this._calcEnclosingRing();\n    }\n    return this._enclosingRing;\n  }\n\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing() {\n    // start with the ealier sweep line event so that the prevSeg\n    // chain doesn't lead us inside of a loop of ours\n    let leftMostEvt = this.events[0];\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i];\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n    }\n    let prevSeg = leftMostEvt.segment.prevInResult();\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    while (true) {\n      // no segment found, thus no ring can enclose us\n      if (!prevSeg) return null;\n\n      // no segments below prev segment found, thus the ring of the prev\n      // segment must loop back around and enclose us\n      if (!prevPrevSeg) return prevSeg.ringOut;\n\n      // if the two segments are of different rings, the ring of the prev\n      // segment must either loop around us or the ring of the prev prev\n      // seg, which would make us and the ring of the prev peers\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut;\n        } else return prevSeg.ringOut.enclosingRing();\n      }\n\n      // two segments are from the same ring, so this was a penisula\n      // of that ring. iterate downward, keep searching\n      prevSeg = prevPrevSeg.prevInResult();\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    }\n  }\n}\nclass PolyOut {\n  constructor(exteriorRing) {\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n  addInterior(ring) {\n    this.interiorRings.push(ring);\n    ring.poly = this;\n  }\n  getGeom() {\n    const geom = [this.exteriorRing.getGeom()];\n    // exterior ring was all (within rounding error of angle calc) colinear points\n    if (geom[0] === null) return null;\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom();\n      // interior ring was all (within rounding error of angle calc) colinear points\n      if (ringGeom === null) continue;\n      geom.push(ringGeom);\n    }\n    return geom;\n  }\n}\nclass MultiPolyOut {\n  constructor(rings) {\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n  getGeom() {\n    const geom = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom();\n      // exterior ring was all (within rounding error of angle calc) colinear points\n      if (polyGeom === null) continue;\n      geom.push(polyGeom);\n    }\n    return geom;\n  }\n  _composePolys(rings) {\n    const polys = [];\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i];\n      if (ring.poly) continue;\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n        const enclosingRing = ring.enclosingRing();\n        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n        enclosingRing.poly.addInterior(ring);\n      }\n    }\n    return polys;\n  }\n}\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nclass SweepLine {\n  constructor(queue) {\n    let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n    this.queue = queue;\n    this.tree = new splaytree__WEBPACK_IMPORTED_MODULE_0__[\"default\"](comparator);\n    this.segments = [];\n  }\n  process(event) {\n    const segment = event.segment;\n    const newEvents = [];\n\n    // if we've already been consumed by another segment,\n    // clean up our body parts and get out\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n      return newEvents;\n    }\n    const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);\n    if (!node) throw new Error(`Unable to find segment #${segment.id} ` + `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` + `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` + \"in SweepLine tree.\");\n    let prevNode = node;\n    let nextNode = node;\n    let prevSeg = undefined;\n    let nextSeg = undefined;\n\n    // skip consumed segments still in tree\n    while (prevSeg === undefined) {\n      prevNode = this.tree.prev(prevNode);\n      if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n    }\n\n    // skip consumed segments still in tree\n    while (nextSeg === undefined) {\n      nextNode = this.tree.next(nextNode);\n      if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n    }\n    if (event.isLeft) {\n      // Check for intersections against the previous segment in the sweep line\n      let prevMySplitter = null;\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment);\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n\n      // Check for intersections against the next segment in the sweep line\n      let nextMySplitter = null;\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment);\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n          if (!nextSeg.isAnEndpoint(nextInter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n\n      // For simplicity, even if we find more than one intersection we only\n      // spilt on the 'earliest' (sweep-line style) of the intersections.\n      // The other intersection will be handled in a future process().\n      if (prevMySplitter !== null || nextMySplitter !== null) {\n        let mySplitter = null;\n        if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n          const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n        }\n\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        this.queue.remove(segment.rightSE);\n        newEvents.push(segment.rightSE);\n        const newEventsFromSplit = segment.split(mySplitter);\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i]);\n        }\n      }\n      if (newEvents.length > 0) {\n        // We found some intersections, so re-do the current event to\n        // make sure sweep line ordering is totally consistent for later\n        // use with the segment 'prev' pointers\n        this.tree.remove(segment);\n        newEvents.push(event);\n      } else {\n        // done with left event\n        this.segments.push(segment);\n        segment.prev = prevSeg;\n      }\n    } else {\n      // event.isRight\n\n      // since we're about to be removed from the sweep line, check for\n      // intersections between our previous and next segments\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg);\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      this.tree.remove(segment);\n    }\n    return newEvents;\n  }\n\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    // Rounding errors can cause changes in ordering,\n    // so remove afected segments and right sweep events before splitting\n    // removeNode() doesn't work, so have re-find the seg\n    // https://github.com/w8r/splay-tree/pull/5\n    this.tree.remove(seg);\n    const rightSE = seg.rightSE;\n    this.queue.remove(rightSE);\n    const newEvents = seg.split(pt);\n    newEvents.push(rightSE);\n    // splitting can trigger consumption\n    if (seg.consumedBy === undefined) this.tree.add(seg);\n    return newEvents;\n  }\n}\n\n// Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.\nconst POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\nconst POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\nclass Operation {\n  run(type, geom, moreGeoms) {\n    operation.type = type;\n    rounder.reset();\n\n    /* Convert inputs to MultiPoly objects */\n    const multipolys = [new MultiPolyIn(geom, true)];\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n    }\n    operation.numMultiPolys = multipolys.length;\n\n    /* BBox optimization for difference operation\n     * If the bbox of a multipolygon that's part of the clipping doesn't\n     * intersect the bbox of the subject at all, we can just drop that\n     * multiploygon. */\n    if (operation.type === \"difference\") {\n      // in place removal\n      const subject = multipolys[0];\n      let i = 1;\n      while (i < multipolys.length) {\n        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;else multipolys.splice(i, 1);\n      }\n    }\n\n    /* BBox optimization for intersection operation\n     * If we can find any pair of multipolygons whose bbox does not overlap,\n     * then the result will be empty. */\n    if (operation.type === \"intersection\") {\n      // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n      //       it could be optimized to O(n * ln(n))\n      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n        const mpA = multipolys[i];\n        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n        }\n      }\n    }\n\n    /* Put segment endpoints in a priority queue */\n    const queue = new splaytree__WEBPACK_IMPORTED_MODULE_0__[\"default\"](SweepEvent.compare);\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents();\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.insert(sweepEvents[j]);\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error(\"Infinite loop when putting segment endpoints in a priority queue \" + \"(queue size too big).\");\n        }\n      }\n    }\n\n    /* Pass the sweep line over those endpoints */\n    const sweepLine = new SweepLine(queue);\n    let prevQueueSize = queue.size;\n    let node = queue.pop();\n    while (node) {\n      const evt = node.key;\n      if (queue.size === prevQueueSize) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        const seg = evt.segment;\n        throw new Error(`Unable to pop() ${evt.isLeft ? \"left\" : \"right\"} SweepEvent ` + `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` + `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` + `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);\n      }\n      if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(queue size too big).\");\n      }\n      if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(too many sweep line segments).\");\n      }\n      const newEvents = sweepLine.process(evt);\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt = newEvents[i];\n        if (evt.consumedBy === undefined) queue.insert(evt);\n      }\n      prevQueueSize = queue.size;\n      node = queue.pop();\n    }\n\n    // free some memory we don't need anymore\n    rounder.reset();\n\n    /* Collect and compile segments we're keeping into a multipolygon */\n    const ringsOut = RingOut.factory(sweepLine.segments);\n    const result = new MultiPolyOut(ringsOut);\n    return result.getGeom();\n  }\n}\n\n// singleton available by import\nconst operation = new Operation();\n\nconst union = function (geom) {\n  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    moreGeoms[_key - 1] = arguments[_key];\n  }\n  return operation.run(\"union\", geom, moreGeoms);\n};\nconst intersection = function (geom) {\n  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    moreGeoms[_key2 - 1] = arguments[_key2];\n  }\n  return operation.run(\"intersection\", geom, moreGeoms);\n};\nconst xor = function (geom) {\n  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    moreGeoms[_key3 - 1] = arguments[_key3];\n  }\n  return operation.run(\"xor\", geom, moreGeoms);\n};\nconst difference = function (subjectGeom) {\n  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    clippingGeoms[_key4 - 1] = arguments[_key4];\n  }\n  return operation.run(\"difference\", subjectGeom, clippingGeoms);\n};\nvar index = {\n  union: union,\n  intersection: intersection,\n  xor: xor,\n  difference: difference\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9seWdvbi1jbGlwcGluZy9kaXN0L3BvbHlnb24tY2xpcHBpbmcuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrQztBQUNXOztBQUU3QztBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQU0sa0JBQWtCLFFBQVE7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpREFBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMkRBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxVQUFVO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0RBQStELE1BQU0sSUFBSSxNQUFNO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0VBQWdFO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxlQUFlO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxVQUFVO0FBQ2hFO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQSxxREFBcUQsVUFBVTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLFVBQVUsU0FBUyxVQUFVLCtDQUErQyxTQUFTLElBQUksU0FBUztBQUM3Szs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsVUFBVTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsVUFBVTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVksUUFBUSx1QkFBdUIsSUFBSSx1QkFBdUIsYUFBYSx3QkFBd0IsSUFBSSx3QkFBd0I7QUFDak07QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSw4REFBOEQ7QUFDL0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBLHNEQUFzRCxVQUFVO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlEQUFTO0FBQy9CLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtCQUErQixtQkFBbUIsWUFBWSxJQUFJLFlBQVksa0JBQWtCLFFBQVEsUUFBUSxtQkFBbUIsSUFBSSxtQkFBbUIsYUFBYSxvQkFBb0IsSUFBSSxvQkFBb0I7QUFDOVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhGQUE4RixhQUFhO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csZUFBZTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLGVBQWU7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxlQUFlO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2JvdW5kYXJ5LWRlbGluZWF0aW9uLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9wb2x5Z29uLWNsaXBwaW5nL2Rpc3QvcG9seWdvbi1jbGlwcGluZy5lc20uanM/Y2EyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3BsYXlUcmVlIGZyb20gJ3NwbGF5dHJlZSc7XG5pbXBvcnQgeyBvcmllbnQyZCB9IGZyb20gJ3JvYnVzdC1wcmVkaWNhdGVzJztcblxuLyoqXG4gKiBBIGJvdW5kaW5nIGJveCBoYXMgdGhlIGZvcm1hdDpcbiAqXG4gKiAgeyBsbDogeyB4OiB4bWluLCB5OiB5bWluIH0sIHVyOiB7IHg6IHhtYXgsIHk6IHltYXggfSB9XG4gKlxuICovXG5cbmNvbnN0IGlzSW5CYm94ID0gKGJib3gsIHBvaW50KSA9PiB7XG4gIHJldHVybiBiYm94LmxsLnggPD0gcG9pbnQueCAmJiBwb2ludC54IDw9IGJib3gudXIueCAmJiBiYm94LmxsLnkgPD0gcG9pbnQueSAmJiBwb2ludC55IDw9IGJib3gudXIueTtcbn07XG5cbi8qIFJldHVybnMgZWl0aGVyIG51bGwsIG9yIGEgYmJveCAoYWthIGFuIG9yZGVyZWQgcGFpciBvZiBwb2ludHMpXG4gKiBJZiB0aGVyZSBpcyBvbmx5IG9uZSBwb2ludCBvZiBvdmVybGFwLCBhIGJib3ggd2l0aCBpZGVudGljYWwgcG9pbnRzXG4gKiB3aWxsIGJlIHJldHVybmVkICovXG5jb25zdCBnZXRCYm94T3ZlcmxhcCA9IChiMSwgYjIpID0+IHtcbiAgLy8gY2hlY2sgaWYgdGhlIGJib3hlcyBvdmVybGFwIGF0IGFsbFxuICBpZiAoYjIudXIueCA8IGIxLmxsLnggfHwgYjEudXIueCA8IGIyLmxsLnggfHwgYjIudXIueSA8IGIxLmxsLnkgfHwgYjEudXIueSA8IGIyLmxsLnkpIHJldHVybiBudWxsO1xuXG4gIC8vIGZpbmQgdGhlIG1pZGRsZSB0d28gWCB2YWx1ZXNcbiAgY29uc3QgbG93ZXJYID0gYjEubGwueCA8IGIyLmxsLnggPyBiMi5sbC54IDogYjEubGwueDtcbiAgY29uc3QgdXBwZXJYID0gYjEudXIueCA8IGIyLnVyLnggPyBiMS51ci54IDogYjIudXIueDtcblxuICAvLyBmaW5kIHRoZSBtaWRkbGUgdHdvIFkgdmFsdWVzXG4gIGNvbnN0IGxvd2VyWSA9IGIxLmxsLnkgPCBiMi5sbC55ID8gYjIubGwueSA6IGIxLmxsLnk7XG4gIGNvbnN0IHVwcGVyWSA9IGIxLnVyLnkgPCBiMi51ci55ID8gYjEudXIueSA6IGIyLnVyLnk7XG5cbiAgLy8gcHV0IHRob3NlIG1pZGRsZSB2YWx1ZXMgdG9nZXRoZXIgdG8gZ2V0IHRoZSBvdmVybGFwXG4gIHJldHVybiB7XG4gICAgbGw6IHtcbiAgICAgIHg6IGxvd2VyWCxcbiAgICAgIHk6IGxvd2VyWVxuICAgIH0sXG4gICAgdXI6IHtcbiAgICAgIHg6IHVwcGVyWCxcbiAgICAgIHk6IHVwcGVyWVxuICAgIH1cbiAgfTtcbn07XG5cbi8qIEphdmFzY3JpcHQgZG9lc24ndCBkbyBpbnRlZ2VyIG1hdGguIEV2ZXJ5dGhpbmcgaXNcbiAqIGZsb2F0aW5nIHBvaW50IHdpdGggcGVyY2lzaW9uIE51bWJlci5FUFNJTE9OLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9FUFNJTE9OXG4gKi9cblxubGV0IGVwc2lsb24gPSBOdW1iZXIuRVBTSUxPTjtcblxuLy8gSUUgUG9seWZpbGxcbmlmIChlcHNpbG9uID09PSB1bmRlZmluZWQpIGVwc2lsb24gPSBNYXRoLnBvdygyLCAtNTIpO1xuY29uc3QgRVBTSUxPTl9TUSA9IGVwc2lsb24gKiBlcHNpbG9uO1xuXG4vKiBGTFAgY29tcGFyYXRvciAqL1xuY29uc3QgY21wID0gKGEsIGIpID0+IHtcbiAgLy8gY2hlY2sgaWYgdGhleSdyZSBib3RoIDBcbiAgaWYgKC1lcHNpbG9uIDwgYSAmJiBhIDwgZXBzaWxvbikge1xuICAgIGlmICgtZXBzaWxvbiA8IGIgJiYgYiA8IGVwc2lsb24pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHRoZXkncmUgZmxwIGVxdWFsXG4gIGNvbnN0IGFiID0gYSAtIGI7XG4gIGlmIChhYiAqIGFiIDwgRVBTSUxPTl9TUSAqIGEgKiBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBub3JtYWwgY29tcGFyaXNvblxuICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG59O1xuXG4vKipcbiAqIFRoaXMgY2xhc3Mgcm91bmRzIGluY29taW5nIHZhbHVlcyBzdWZmaWNpZW50bHkgc28gdGhhdFxuICogZmxvYXRpbmcgcG9pbnRzIHByb2JsZW1zIGFyZSwgZm9yIHRoZSBtb3N0IHBhcnQsIGF2b2lkZWQuXG4gKlxuICogSW5jb21pbmcgcG9pbnRzIGFyZSBoYXZlIHRoZWlyIHggJiB5IHZhbHVlcyB0ZXN0ZWQgYWdhaW5zdFxuICogYWxsIHByZXZpb3VzbHkgc2VlbiB4ICYgeSB2YWx1ZXMuIElmIGVpdGhlciBpcyAndG9vIGNsb3NlJ1xuICogdG8gYSBwcmV2aW91c2x5IHNlZW4gdmFsdWUsIGl0J3MgdmFsdWUgaXMgJ3NuYXBwZWQnIHRvIHRoZVxuICogcHJldmlvdXNseSBzZWVuIHZhbHVlLlxuICpcbiAqIEFsbCBwb2ludHMgc2hvdWxkIGJlIHJvdW5kZWQgYnkgdGhpcyBjbGFzcyBiZWZvcmUgYmVpbmdcbiAqIHN0b3JlZCBpbiBhbnkgZGF0YSBzdHJ1Y3R1cmVzIGluIHRoZSByZXN0IG9mIHRoaXMgYWxnb3JpdGhtLlxuICovXG5cbmNsYXNzIFB0Um91bmRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnhSb3VuZGVyID0gbmV3IENvb3JkUm91bmRlcigpO1xuICAgIHRoaXMueVJvdW5kZXIgPSBuZXcgQ29vcmRSb3VuZGVyKCk7XG4gIH1cbiAgcm91bmQoeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0aGlzLnhSb3VuZGVyLnJvdW5kKHgpLFxuICAgICAgeTogdGhpcy55Um91bmRlci5yb3VuZCh5KVxuICAgIH07XG4gIH1cbn1cbmNsYXNzIENvb3JkUm91bmRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudHJlZSA9IG5ldyBTcGxheVRyZWUoKTtcbiAgICAvLyBwcmVzZWVkIHdpdGggMCBzbyB3ZSBkb24ndCBlbmQgdXAgd2l0aCB2YWx1ZXMgPCBOdW1iZXIuRVBTSUxPTlxuICAgIHRoaXMucm91bmQoMCk7XG4gIH1cblxuICAvLyBOb3RlOiB0aGlzIGNhbiByb3VuZHMgaW5wdXQgdmFsdWVzIGJhY2t3YXJkcyBvciBmb3J3YXJkcy5cbiAgLy8gICAgICAgWW91IG1pZ2h0IGFzaywgd2h5IG5vdCByZXN0cmljdCB0aGlzIHRvIGp1c3Qgcm91bmRpbmdcbiAgLy8gICAgICAgZm9yd2FyZHM/IFdvdWxkbid0IHRoYXQgYWxsb3cgbGVmdCBlbmRwb2ludHMgdG8gYWx3YXlzXG4gIC8vICAgICAgIHJlbWFpbiBsZWZ0IGVuZHBvaW50cyBkdXJpbmcgc3BsaXR0aW5nIChuZXZlciBjaGFuZ2UgdG9cbiAgLy8gICAgICAgcmlnaHQpLiBObyAtIGl0IHdvdWxkbid0LCBiZWNhdXNlIHdlIHNuYXAgaW50ZXJzZWN0aW9uc1xuICAvLyAgICAgICB0byBlbmRwb2ludHMgKHRvIGVzdGFibGlzaCBpbmRlcGVuZGVuY2UgZnJvbSB0aGUgc2VnbWVudFxuICAvLyAgICAgICBhbmdsZSBmb3IgdC1pbnRlcnNlY3Rpb25zKS5cbiAgcm91bmQoY29vcmQpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy50cmVlLmFkZChjb29yZCk7XG4gICAgY29uc3QgcHJldk5vZGUgPSB0aGlzLnRyZWUucHJldihub2RlKTtcbiAgICBpZiAocHJldk5vZGUgIT09IG51bGwgJiYgY21wKG5vZGUua2V5LCBwcmV2Tm9kZS5rZXkpID09PSAwKSB7XG4gICAgICB0aGlzLnRyZWUucmVtb3ZlKGNvb3JkKTtcbiAgICAgIHJldHVybiBwcmV2Tm9kZS5rZXk7XG4gICAgfVxuICAgIGNvbnN0IG5leHROb2RlID0gdGhpcy50cmVlLm5leHQobm9kZSk7XG4gICAgaWYgKG5leHROb2RlICE9PSBudWxsICYmIGNtcChub2RlLmtleSwgbmV4dE5vZGUua2V5KSA9PT0gMCkge1xuICAgICAgdGhpcy50cmVlLnJlbW92ZShjb29yZCk7XG4gICAgICByZXR1cm4gbmV4dE5vZGUua2V5O1xuICAgIH1cbiAgICByZXR1cm4gY29vcmQ7XG4gIH1cbn1cblxuLy8gc2luZ2xldG9uIGF2YWlsYWJsZSBieSBpbXBvcnRcbmNvbnN0IHJvdW5kZXIgPSBuZXcgUHRSb3VuZGVyKCk7XG5cbi8qIENyb3NzIFByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMgd2l0aCBmaXJzdCBwb2ludCBhdCBvcmlnaW4gKi9cbmNvbnN0IGNyb3NzUHJvZHVjdCA9IChhLCBiKSA9PiBhLnggKiBiLnkgLSBhLnkgKiBiLng7XG5cbi8qIERvdCBQcm9kdWN0IG9mIHR3byB2ZWN0b3JzIHdpdGggZmlyc3QgcG9pbnQgYXQgb3JpZ2luICovXG5jb25zdCBkb3RQcm9kdWN0ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcblxuLyogQ29tcGFyYXRvciBmb3IgdHdvIHZlY3RvcnMgd2l0aCBzYW1lIHN0YXJ0aW5nIHBvaW50ICovXG5jb25zdCBjb21wYXJlVmVjdG9yQW5nbGVzID0gKGJhc2VQdCwgZW5kUHQxLCBlbmRQdDIpID0+IHtcbiAgY29uc3QgcmVzID0gb3JpZW50MmQoYmFzZVB0LngsIGJhc2VQdC55LCBlbmRQdDEueCwgZW5kUHQxLnksIGVuZFB0Mi54LCBlbmRQdDIueSk7XG4gIGlmIChyZXMgPiAwKSByZXR1cm4gLTE7XG4gIGlmIChyZXMgPCAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59O1xuY29uc3QgbGVuZ3RoID0gdiA9PiBNYXRoLnNxcnQoZG90UHJvZHVjdCh2LCB2KSk7XG5cbi8qIEdldCB0aGUgc2luZSBvZiB0aGUgYW5nbGUgZnJvbSBwU2hhcmVkIC0+IHBBbmdsZSB0byBwU2hhZWQgLT4gcEJhc2UgKi9cbmNvbnN0IHNpbmVPZkFuZ2xlID0gKHBTaGFyZWQsIHBCYXNlLCBwQW5nbGUpID0+IHtcbiAgY29uc3QgdkJhc2UgPSB7XG4gICAgeDogcEJhc2UueCAtIHBTaGFyZWQueCxcbiAgICB5OiBwQmFzZS55IC0gcFNoYXJlZC55XG4gIH07XG4gIGNvbnN0IHZBbmdsZSA9IHtcbiAgICB4OiBwQW5nbGUueCAtIHBTaGFyZWQueCxcbiAgICB5OiBwQW5nbGUueSAtIHBTaGFyZWQueVxuICB9O1xuICByZXR1cm4gY3Jvc3NQcm9kdWN0KHZBbmdsZSwgdkJhc2UpIC8gbGVuZ3RoKHZBbmdsZSkgLyBsZW5ndGgodkJhc2UpO1xufTtcblxuLyogR2V0IHRoZSBjb3NpbmUgb2YgdGhlIGFuZ2xlIGZyb20gcFNoYXJlZCAtPiBwQW5nbGUgdG8gcFNoYWVkIC0+IHBCYXNlICovXG5jb25zdCBjb3NpbmVPZkFuZ2xlID0gKHBTaGFyZWQsIHBCYXNlLCBwQW5nbGUpID0+IHtcbiAgY29uc3QgdkJhc2UgPSB7XG4gICAgeDogcEJhc2UueCAtIHBTaGFyZWQueCxcbiAgICB5OiBwQmFzZS55IC0gcFNoYXJlZC55XG4gIH07XG4gIGNvbnN0IHZBbmdsZSA9IHtcbiAgICB4OiBwQW5nbGUueCAtIHBTaGFyZWQueCxcbiAgICB5OiBwQW5nbGUueSAtIHBTaGFyZWQueVxuICB9O1xuICByZXR1cm4gZG90UHJvZHVjdCh2QW5nbGUsIHZCYXNlKSAvIGxlbmd0aCh2QW5nbGUpIC8gbGVuZ3RoKHZCYXNlKTtcbn07XG5cbi8qIEdldCB0aGUgeCBjb29yZGluYXRlIHdoZXJlIHRoZSBnaXZlbiBsaW5lIChkZWZpbmVkIGJ5IGEgcG9pbnQgYW5kIHZlY3RvcilcbiAqIGNyb3NzZXMgdGhlIGhvcml6b250YWwgbGluZSB3aXRoIHRoZSBnaXZlbiB5IGNvb3JkaWFudGUuXG4gKiBJbiB0aGUgY2FzZSBvZiBwYXJyYWxsZWwgbGluZXMgKGluY2x1ZGluZyBvdmVybGFwcGluZyBvbmVzKSByZXR1cm5zIG51bGwuICovXG5jb25zdCBob3Jpem9udGFsSW50ZXJzZWN0aW9uID0gKHB0LCB2LCB5KSA9PiB7XG4gIGlmICh2LnkgPT09IDApIHJldHVybiBudWxsO1xuICByZXR1cm4ge1xuICAgIHg6IHB0LnggKyB2LnggLyB2LnkgKiAoeSAtIHB0LnkpLFxuICAgIHk6IHlcbiAgfTtcbn07XG5cbi8qIEdldCB0aGUgeSBjb29yZGluYXRlIHdoZXJlIHRoZSBnaXZlbiBsaW5lIChkZWZpbmVkIGJ5IGEgcG9pbnQgYW5kIHZlY3RvcilcbiAqIGNyb3NzZXMgdGhlIHZlcnRpY2FsIGxpbmUgd2l0aCB0aGUgZ2l2ZW4geCBjb29yZGlhbnRlLlxuICogSW4gdGhlIGNhc2Ugb2YgcGFycmFsbGVsIGxpbmVzIChpbmNsdWRpbmcgb3ZlcmxhcHBpbmcgb25lcykgcmV0dXJucyBudWxsLiAqL1xuY29uc3QgdmVydGljYWxJbnRlcnNlY3Rpb24gPSAocHQsIHYsIHgpID0+IHtcbiAgaWYgKHYueCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiBwdC55ICsgdi55IC8gdi54ICogKHggLSBwdC54KVxuICB9O1xufTtcblxuLyogR2V0IHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIGxpbmVzLCBlYWNoIGRlZmluZWQgYnkgYSBiYXNlIHBvaW50IGFuZCBhIHZlY3Rvci5cbiAqIEluIHRoZSBjYXNlIG9mIHBhcnJhbGxlbCBsaW5lcyAoaW5jbHVkaW5nIG92ZXJsYXBwaW5nIG9uZXMpIHJldHVybnMgbnVsbC4gKi9cbmNvbnN0IGludGVyc2VjdGlvbiQxID0gKHB0MSwgdjEsIHB0MiwgdjIpID0+IHtcbiAgLy8gdGFrZSBzb21lIHNob3J0Y3V0cyBmb3IgdmVydGljYWwgYW5kIGhvcml6b250YWwgbGluZXNcbiAgLy8gdGhpcyBhbHNvIGVuc3VyZXMgd2UgZG9uJ3QgY2FsY3VsYXRlIGFuIGludGVyc2VjdGlvbiBhbmQgdGhlbiBkaXNjb3ZlclxuICAvLyBpdCdzIGFjdHVhbGx5IG91dHNpZGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgbGluZVxuICBpZiAodjEueCA9PT0gMCkgcmV0dXJuIHZlcnRpY2FsSW50ZXJzZWN0aW9uKHB0MiwgdjIsIHB0MS54KTtcbiAgaWYgKHYyLnggPT09IDApIHJldHVybiB2ZXJ0aWNhbEludGVyc2VjdGlvbihwdDEsIHYxLCBwdDIueCk7XG4gIGlmICh2MS55ID09PSAwKSByZXR1cm4gaG9yaXpvbnRhbEludGVyc2VjdGlvbihwdDIsIHYyLCBwdDEueSk7XG4gIGlmICh2Mi55ID09PSAwKSByZXR1cm4gaG9yaXpvbnRhbEludGVyc2VjdGlvbihwdDEsIHYxLCBwdDIueSk7XG5cbiAgLy8gR2VuZXJhbCBjYXNlIGZvciBub24tb3ZlcmxhcHBpbmcgc2VnbWVudHMuXG4gIC8vIFRoaXMgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIFNjaG5laWRlciBhbmQgRWJlcmx5LlxuICAvLyBodHRwOi8vd3d3LmNpbWVjLm9yZy5hci9+bmNhbHZvL1NjaG5laWRlcl9FYmVybHkucGRmIC0gcGcgMjQ0XG5cbiAgY29uc3Qga3Jvc3MgPSBjcm9zc1Byb2R1Y3QodjEsIHYyKTtcbiAgaWYgKGtyb3NzID09IDApIHJldHVybiBudWxsO1xuICBjb25zdCB2ZSA9IHtcbiAgICB4OiBwdDIueCAtIHB0MS54LFxuICAgIHk6IHB0Mi55IC0gcHQxLnlcbiAgfTtcbiAgY29uc3QgZDEgPSBjcm9zc1Byb2R1Y3QodmUsIHYxKSAvIGtyb3NzO1xuICBjb25zdCBkMiA9IGNyb3NzUHJvZHVjdCh2ZSwgdjIpIC8ga3Jvc3M7XG5cbiAgLy8gdGFrZSB0aGUgYXZlcmFnZSBvZiB0aGUgdHdvIGNhbGN1bGF0aW9ucyB0byBtaW5pbWl6ZSByb3VuZGluZyBlcnJvclxuICBjb25zdCB4MSA9IHB0MS54ICsgZDIgKiB2MS54LFxuICAgIHgyID0gcHQyLnggKyBkMSAqIHYyLng7XG4gIGNvbnN0IHkxID0gcHQxLnkgKyBkMiAqIHYxLnksXG4gICAgeTIgPSBwdDIueSArIGQxICogdjIueTtcbiAgY29uc3QgeCA9ICh4MSArIHgyKSAvIDI7XG4gIGNvbnN0IHkgPSAoeTEgKyB5MikgLyAyO1xuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufTtcblxuY2xhc3MgU3dlZXBFdmVudCB7XG4gIC8vIGZvciBvcmRlcmluZyBzd2VlcCBldmVudHMgaW4gdGhlIHN3ZWVwIGV2ZW50IHF1ZXVlXG4gIHN0YXRpYyBjb21wYXJlKGEsIGIpIHtcbiAgICAvLyBmYXZvciBldmVudCB3aXRoIGEgcG9pbnQgdGhhdCB0aGUgc3dlZXAgbGluZSBoaXRzIGZpcnN0XG4gICAgY29uc3QgcHRDbXAgPSBTd2VlcEV2ZW50LmNvbXBhcmVQb2ludHMoYS5wb2ludCwgYi5wb2ludCk7XG4gICAgaWYgKHB0Q21wICE9PSAwKSByZXR1cm4gcHRDbXA7XG5cbiAgICAvLyB0aGUgcG9pbnRzIGFyZSB0aGUgc2FtZSwgc28gbGluayB0aGVtIGlmIG5lZWRlZFxuICAgIGlmIChhLnBvaW50ICE9PSBiLnBvaW50KSBhLmxpbmsoYik7XG5cbiAgICAvLyBmYXZvciByaWdodCBldmVudHMgb3ZlciBsZWZ0XG4gICAgaWYgKGEuaXNMZWZ0ICE9PSBiLmlzTGVmdCkgcmV0dXJuIGEuaXNMZWZ0ID8gMSA6IC0xO1xuXG4gICAgLy8gd2UgaGF2ZSB0d28gbWF0Y2hpbmcgbGVmdCBvciByaWdodCBlbmRwb2ludHNcbiAgICAvLyBvcmRlcmluZyBvZiB0aGlzIGNhc2UgaXMgdGhlIHNhbWUgYXMgZm9yIHRoZWlyIHNlZ21lbnRzXG4gICAgcmV0dXJuIFNlZ21lbnQuY29tcGFyZShhLnNlZ21lbnQsIGIuc2VnbWVudCk7XG4gIH1cblxuICAvLyBmb3Igb3JkZXJpbmcgcG9pbnRzIGluIHN3ZWVwIGxpbmUgb3JkZXJcbiAgc3RhdGljIGNvbXBhcmVQb2ludHMoYVB0LCBiUHQpIHtcbiAgICBpZiAoYVB0LnggPCBiUHQueCkgcmV0dXJuIC0xO1xuICAgIGlmIChhUHQueCA+IGJQdC54KSByZXR1cm4gMTtcbiAgICBpZiAoYVB0LnkgPCBiUHQueSkgcmV0dXJuIC0xO1xuICAgIGlmIChhUHQueSA+IGJQdC55KSByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8vIFdhcm5pbmc6ICdwb2ludCcgaW5wdXQgd2lsbCBiZSBtb2RpZmllZCBhbmQgcmUtdXNlZCAoZm9yIHBlcmZvcm1hbmNlKVxuICBjb25zdHJ1Y3Rvcihwb2ludCwgaXNMZWZ0KSB7XG4gICAgaWYgKHBvaW50LmV2ZW50cyA9PT0gdW5kZWZpbmVkKSBwb2ludC5ldmVudHMgPSBbdGhpc107ZWxzZSBwb2ludC5ldmVudHMucHVzaCh0aGlzKTtcbiAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XG4gICAgdGhpcy5pc0xlZnQgPSBpc0xlZnQ7XG4gICAgLy8gdGhpcy5zZWdtZW50LCB0aGlzLm90aGVyU0Ugc2V0IGJ5IGZhY3RvcnlcbiAgfVxuICBsaW5rKG90aGVyKSB7XG4gICAgaWYgKG90aGVyLnBvaW50ID09PSB0aGlzLnBvaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBsaW5rIGFscmVhZHkgbGlua2VkIGV2ZW50c1wiKTtcbiAgICB9XG4gICAgY29uc3Qgb3RoZXJFdmVudHMgPSBvdGhlci5wb2ludC5ldmVudHM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBvdGhlckV2ZW50cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IGV2dCA9IG90aGVyRXZlbnRzW2ldO1xuICAgICAgdGhpcy5wb2ludC5ldmVudHMucHVzaChldnQpO1xuICAgICAgZXZ0LnBvaW50ID0gdGhpcy5wb2ludDtcbiAgICB9XG4gICAgdGhpcy5jaGVja0ZvckNvbnN1bWluZygpO1xuICB9XG5cbiAgLyogRG8gYSBwYXNzIG92ZXIgb3VyIGxpbmtlZCBldmVudHMgYW5kIGNoZWNrIHRvIHNlZSBpZiBhbnkgcGFpclxuICAgKiBvZiBzZWdtZW50cyBtYXRjaCwgYW5kIHNob3VsZCBiZSBjb25zdW1lZC4gKi9cbiAgY2hlY2tGb3JDb25zdW1pbmcoKSB7XG4gICAgLy8gRklYTUU6IFRoZSBsb29wcyBpbiB0aGlzIG1ldGhvZCBydW4gTyhuXjIpID0+IG5vIGdvb2QuXG4gICAgLy8gICAgICAgIE1haW50YWluIGxpdHRsZSBvcmRlcmVkIHN3ZWVwIGV2ZW50IHRyZWVzP1xuICAgIC8vICAgICAgICBDYW4gd2UgbWFpbnRhaW5pbmcgYW4gb3JkZXJpbmcgdGhhdCBhdm9pZHMgdGhlIG5lZWRcbiAgICAvLyAgICAgICAgZm9yIHRoZSByZS1zb3J0aW5nIHdpdGggZ2V0TGVmdG1vc3RDb21wYXJhdG9yIGluIGdlb20tb3V0P1xuXG4gICAgLy8gQ29tcGFyZSBlYWNoIHBhaXIgb2YgZXZlbnRzIHRvIHNlZSBpZiBvdGhlciBldmVudHMgYWxzbyBtYXRjaFxuICAgIGNvbnN0IG51bUV2ZW50cyA9IHRoaXMucG9pbnQuZXZlbnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUV2ZW50czsgaSsrKSB7XG4gICAgICBjb25zdCBldnQxID0gdGhpcy5wb2ludC5ldmVudHNbaV07XG4gICAgICBpZiAoZXZ0MS5zZWdtZW50LmNvbnN1bWVkQnkgIT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBudW1FdmVudHM7IGorKykge1xuICAgICAgICBjb25zdCBldnQyID0gdGhpcy5wb2ludC5ldmVudHNbal07XG4gICAgICAgIGlmIChldnQyLmNvbnN1bWVkQnkgIT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICAgIGlmIChldnQxLm90aGVyU0UucG9pbnQuZXZlbnRzICE9PSBldnQyLm90aGVyU0UucG9pbnQuZXZlbnRzKSBjb250aW51ZTtcbiAgICAgICAgZXZ0MS5zZWdtZW50LmNvbnN1bWUoZXZ0Mi5zZWdtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0QXZhaWxhYmxlTGlua2VkRXZlbnRzKCkge1xuICAgIC8vIHBvaW50LmV2ZW50cyBpcyBhbHdheXMgb2YgbGVuZ3RoIDIgb3IgZ3JlYXRlclxuICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gdGhpcy5wb2ludC5ldmVudHMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCBldnQgPSB0aGlzLnBvaW50LmV2ZW50c1tpXTtcbiAgICAgIGlmIChldnQgIT09IHRoaXMgJiYgIWV2dC5zZWdtZW50LnJpbmdPdXQgJiYgZXZ0LnNlZ21lbnQuaXNJblJlc3VsdCgpKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGV2dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gZm9yIHNvcnRpbmcgbGlua2VkIGV2ZW50cyB0aGF0IHdpbGxcbiAgICogZmF2b3IgdGhlIGV2ZW50IHRoYXQgd2lsbCBnaXZlIHVzIHRoZSBzbWFsbGVzdCBsZWZ0LXNpZGUgYW5nbGUuXG4gICAqIEFsbCByaW5nIGNvbnN0cnVjdGlvbiBzdGFydHMgYXMgbG93IGFzIHBvc3NpYmxlIGhlYWRpbmcgdG8gdGhlIHJpZ2h0LFxuICAgKiBzbyBieSBhbHdheXMgdHVybmluZyBsZWZ0IGFzIHNoYXJwIGFzIHBvc3NpYmxlIHdlJ2xsIGdldCBwb2x5Z29uc1xuICAgKiB3aXRob3V0IHVuY2Vzc2FyeSBsb29wcyAmIGhvbGVzLlxuICAgKlxuICAgKiBUaGUgY29tcGFyYXRvciBmdW5jdGlvbiBoYXMgYSBjb21wdXRlIGNhY2hlIHN1Y2ggdGhhdCBpdCBhdm9pZHNcbiAgICogcmUtY29tcHV0aW5nIGFscmVhZHktY29tcHV0ZWQgdmFsdWVzLlxuICAgKi9cbiAgZ2V0TGVmdG1vc3RDb21wYXJhdG9yKGJhc2VFdmVudCkge1xuICAgIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGZpbGxDYWNoZSA9IGxpbmtlZEV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IG5leHRFdmVudCA9IGxpbmtlZEV2ZW50Lm90aGVyU0U7XG4gICAgICBjYWNoZS5zZXQobGlua2VkRXZlbnQsIHtcbiAgICAgICAgc2luZTogc2luZU9mQW5nbGUodGhpcy5wb2ludCwgYmFzZUV2ZW50LnBvaW50LCBuZXh0RXZlbnQucG9pbnQpLFxuICAgICAgICBjb3NpbmU6IGNvc2luZU9mQW5nbGUodGhpcy5wb2ludCwgYmFzZUV2ZW50LnBvaW50LCBuZXh0RXZlbnQucG9pbnQpXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoYSwgYikgPT4ge1xuICAgICAgaWYgKCFjYWNoZS5oYXMoYSkpIGZpbGxDYWNoZShhKTtcbiAgICAgIGlmICghY2FjaGUuaGFzKGIpKSBmaWxsQ2FjaGUoYik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNpbmU6IGFzaW5lLFxuICAgICAgICBjb3NpbmU6IGFjb3NpbmVcbiAgICAgIH0gPSBjYWNoZS5nZXQoYSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNpbmU6IGJzaW5lLFxuICAgICAgICBjb3NpbmU6IGJjb3NpbmVcbiAgICAgIH0gPSBjYWNoZS5nZXQoYik7XG5cbiAgICAgIC8vIGJvdGggb24gb3IgYWJvdmUgeC1heGlzXG4gICAgICBpZiAoYXNpbmUgPj0gMCAmJiBic2luZSA+PSAwKSB7XG4gICAgICAgIGlmIChhY29zaW5lIDwgYmNvc2luZSkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhY29zaW5lID4gYmNvc2luZSkgcmV0dXJuIC0xO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgLy8gYm90aCBiZWxvdyB4LWF4aXNcbiAgICAgIGlmIChhc2luZSA8IDAgJiYgYnNpbmUgPCAwKSB7XG4gICAgICAgIGlmIChhY29zaW5lIDwgYmNvc2luZSkgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYWNvc2luZSA+IGJjb3NpbmUpIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgLy8gb25lIGFib3ZlIHgtYXhpcywgb25lIGJlbG93XG4gICAgICBpZiAoYnNpbmUgPCBhc2luZSkgcmV0dXJuIC0xO1xuICAgICAgaWYgKGJzaW5lID4gYXNpbmUpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBHaXZlIHNlZ21lbnRzIHVuaXF1ZSBJRCdzIHRvIGdldCBjb25zaXN0ZW50IHNvcnRpbmcgb2Zcbi8vIHNlZ21lbnRzIGFuZCBzd2VlcCBldmVudHMgd2hlbiBhbGwgZWxzZSBpcyBpZGVudGljYWxcbmxldCBzZWdtZW50SWQgPSAwO1xuY2xhc3MgU2VnbWVudCB7XG4gIC8qIFRoaXMgY29tcGFyZSgpIGZ1bmN0aW9uIGlzIGZvciBvcmRlcmluZyBzZWdtZW50cyBpbiB0aGUgc3dlZXBcbiAgICogbGluZSB0cmVlLCBhbmQgZG9lcyBzbyBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZyBjcml0ZXJpYTpcbiAgICpcbiAgICogQ29uc2lkZXIgdGhlIHZlcnRpY2FsIGxpbmUgdGhhdCBsaWVzIGFuIGluZmluZXN0aW1hbCBzdGVwIHRvIHRoZVxuICAgKiByaWdodCBvZiB0aGUgcmlnaHQtbW9yZSBvZiB0aGUgdHdvIGxlZnQgZW5kcG9pbnRzIG9mIHRoZSBpbnB1dFxuICAgKiBzZWdtZW50cy4gSW1hZ2luZSBzbG93bHkgbW92aW5nIGEgcG9pbnQgdXAgZnJvbSBuZWdhdGl2ZSBpbmZpbml0eVxuICAgKiBpbiB0aGUgaW5jcmVhc2luZyB5IGRpcmVjdGlvbi4gV2hpY2ggb2YgdGhlIHR3byBzZWdtZW50cyB3aWxsIHRoYXRcbiAgICogcG9pbnQgaW50ZXJzZWN0IGZpcnN0PyBUaGF0IHNlZ21lbnQgY29tZXMgJ2JlZm9yZScgdGhlIG90aGVyIG9uZS5cbiAgICpcbiAgICogSWYgbmVpdGhlciBzZWdtZW50IHdvdWxkIGJlIGludGVyc2VjdGVkIGJ5IHN1Y2ggYSBsaW5lLCAoaWYgb25lXG4gICAqIG9yIG1vcmUgb2YgdGhlIHNlZ21lbnRzIGFyZSB2ZXJ0aWNhbCkgdGhlbiB0aGUgbGluZSB0byBiZSBjb25zaWRlcmVkXG4gICAqIGlzIGRpcmVjdGx5IG9uIHRoZSByaWdodC1tb3JlIG9mIHRoZSB0d28gbGVmdCBpbnB1dHMuXG4gICAqL1xuICBzdGF0aWMgY29tcGFyZShhLCBiKSB7XG4gICAgY29uc3QgYWx4ID0gYS5sZWZ0U0UucG9pbnQueDtcbiAgICBjb25zdCBibHggPSBiLmxlZnRTRS5wb2ludC54O1xuICAgIGNvbnN0IGFyeCA9IGEucmlnaHRTRS5wb2ludC54O1xuICAgIGNvbnN0IGJyeCA9IGIucmlnaHRTRS5wb2ludC54O1xuXG4gICAgLy8gY2hlY2sgaWYgdGhleSdyZSBldmVuIGluIHRoZSBzYW1lIHZlcnRpY2FsIHBsYW5lXG4gICAgaWYgKGJyeCA8IGFseCkgcmV0dXJuIDE7XG4gICAgaWYgKGFyeCA8IGJseCkgcmV0dXJuIC0xO1xuICAgIGNvbnN0IGFseSA9IGEubGVmdFNFLnBvaW50Lnk7XG4gICAgY29uc3QgYmx5ID0gYi5sZWZ0U0UucG9pbnQueTtcbiAgICBjb25zdCBhcnkgPSBhLnJpZ2h0U0UucG9pbnQueTtcbiAgICBjb25zdCBicnkgPSBiLnJpZ2h0U0UucG9pbnQueTtcblxuICAgIC8vIGlzIGxlZnQgZW5kcG9pbnQgb2Ygc2VnbWVudCBCIHRoZSByaWdodC1tb3JlP1xuICAgIGlmIChhbHggPCBibHgpIHtcbiAgICAgIC8vIGFyZSB0aGUgdHdvIHNlZ21lbnRzIGluIHRoZSBzYW1lIGhvcml6b250YWwgcGxhbmU/XG4gICAgICBpZiAoYmx5IDwgYWx5ICYmIGJseSA8IGFyeSkgcmV0dXJuIDE7XG4gICAgICBpZiAoYmx5ID4gYWx5ICYmIGJseSA+IGFyeSkgcmV0dXJuIC0xO1xuXG4gICAgICAvLyBpcyB0aGUgQiBsZWZ0IGVuZHBvaW50IGNvbGluZWFyIHRvIHNlZ21lbnQgQT9cbiAgICAgIGNvbnN0IGFDbXBCTGVmdCA9IGEuY29tcGFyZVBvaW50KGIubGVmdFNFLnBvaW50KTtcbiAgICAgIGlmIChhQ21wQkxlZnQgPCAwKSByZXR1cm4gMTtcbiAgICAgIGlmIChhQ21wQkxlZnQgPiAwKSByZXR1cm4gLTE7XG5cbiAgICAgIC8vIGlzIHRoZSBBIHJpZ2h0IGVuZHBvaW50IGNvbGluZWFyIHRvIHNlZ21lbnQgQiA/XG4gICAgICBjb25zdCBiQ21wQVJpZ2h0ID0gYi5jb21wYXJlUG9pbnQoYS5yaWdodFNFLnBvaW50KTtcbiAgICAgIGlmIChiQ21wQVJpZ2h0ICE9PSAwKSByZXR1cm4gYkNtcEFSaWdodDtcblxuICAgICAgLy8gY29saW5lYXIgc2VnbWVudHMsIGNvbnNpZGVyIHRoZSBvbmUgd2l0aCBsZWZ0LW1vcmVcbiAgICAgIC8vIGxlZnQgZW5kcG9pbnQgdG8gYmUgZmlyc3QgKGFyYml0cmFyeT8pXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8gaXMgbGVmdCBlbmRwb2ludCBvZiBzZWdtZW50IEEgdGhlIHJpZ2h0LW1vcmU/XG4gICAgaWYgKGFseCA+IGJseCkge1xuICAgICAgaWYgKGFseSA8IGJseSAmJiBhbHkgPCBicnkpIHJldHVybiAtMTtcbiAgICAgIGlmIChhbHkgPiBibHkgJiYgYWx5ID4gYnJ5KSByZXR1cm4gMTtcblxuICAgICAgLy8gaXMgdGhlIEEgbGVmdCBlbmRwb2ludCBjb2xpbmVhciB0byBzZWdtZW50IEI/XG4gICAgICBjb25zdCBiQ21wQUxlZnQgPSBiLmNvbXBhcmVQb2ludChhLmxlZnRTRS5wb2ludCk7XG4gICAgICBpZiAoYkNtcEFMZWZ0ICE9PSAwKSByZXR1cm4gYkNtcEFMZWZ0O1xuXG4gICAgICAvLyBpcyB0aGUgQiByaWdodCBlbmRwb2ludCBjb2xpbmVhciB0byBzZWdtZW50IEE/XG4gICAgICBjb25zdCBhQ21wQlJpZ2h0ID0gYS5jb21wYXJlUG9pbnQoYi5yaWdodFNFLnBvaW50KTtcbiAgICAgIGlmIChhQ21wQlJpZ2h0IDwgMCkgcmV0dXJuIDE7XG4gICAgICBpZiAoYUNtcEJSaWdodCA+IDApIHJldHVybiAtMTtcblxuICAgICAgLy8gY29saW5lYXIgc2VnbWVudHMsIGNvbnNpZGVyIHRoZSBvbmUgd2l0aCBsZWZ0LW1vcmVcbiAgICAgIC8vIGxlZnQgZW5kcG9pbnQgdG8gYmUgZmlyc3QgKGFyYml0cmFyeT8pXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBnZXQgaGVyZSwgdGhlIHR3byBsZWZ0IGVuZHBvaW50cyBhcmUgaW4gdGhlIHNhbWVcbiAgICAvLyB2ZXJ0aWNhbCBwbGFuZSwgaWUgYWx4ID09PSBibHhcblxuICAgIC8vIGNvbnNpZGVyIHRoZSBsb3dlciBsZWZ0LWVuZHBvaW50IHRvIGNvbWUgZmlyc3RcbiAgICBpZiAoYWx5IDwgYmx5KSByZXR1cm4gLTE7XG4gICAgaWYgKGFseSA+IGJseSkgcmV0dXJuIDE7XG5cbiAgICAvLyBsZWZ0IGVuZHBvaW50cyBhcmUgaWRlbnRpY2FsXG4gICAgLy8gY2hlY2sgZm9yIGNvbGluZWFyaXR5IGJ5IHVzaW5nIHRoZSBsZWZ0LW1vcmUgcmlnaHQgZW5kcG9pbnRcblxuICAgIC8vIGlzIHRoZSBBIHJpZ2h0IGVuZHBvaW50IG1vcmUgbGVmdC1tb3JlP1xuICAgIGlmIChhcnggPCBicngpIHtcbiAgICAgIGNvbnN0IGJDbXBBUmlnaHQgPSBiLmNvbXBhcmVQb2ludChhLnJpZ2h0U0UucG9pbnQpO1xuICAgICAgaWYgKGJDbXBBUmlnaHQgIT09IDApIHJldHVybiBiQ21wQVJpZ2h0O1xuICAgIH1cblxuICAgIC8vIGlzIHRoZSBCIHJpZ2h0IGVuZHBvaW50IG1vcmUgbGVmdC1tb3JlP1xuICAgIGlmIChhcnggPiBicngpIHtcbiAgICAgIGNvbnN0IGFDbXBCUmlnaHQgPSBhLmNvbXBhcmVQb2ludChiLnJpZ2h0U0UucG9pbnQpO1xuICAgICAgaWYgKGFDbXBCUmlnaHQgPCAwKSByZXR1cm4gMTtcbiAgICAgIGlmIChhQ21wQlJpZ2h0ID4gMCkgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYXJ4ICE9PSBicngpIHtcbiAgICAgIC8vIGFyZSB0aGVzZSB0d28gW2FsbW9zdF0gdmVydGljYWwgc2VnbWVudHMgd2l0aCBvcHBvc2l0ZSBvcmllbnRhdGlvbj9cbiAgICAgIC8vIGlmIHNvLCB0aGUgb25lIHdpdGggdGhlIGxvd2VyIHJpZ2h0IGVuZHBvaW50IGNvbWVzIGZpcnN0XG4gICAgICBjb25zdCBheSA9IGFyeSAtIGFseTtcbiAgICAgIGNvbnN0IGF4ID0gYXJ4IC0gYWx4O1xuICAgICAgY29uc3QgYnkgPSBicnkgLSBibHk7XG4gICAgICBjb25zdCBieCA9IGJyeCAtIGJseDtcbiAgICAgIGlmIChheSA+IGF4ICYmIGJ5IDwgYngpIHJldHVybiAxO1xuICAgICAgaWYgKGF5IDwgYXggJiYgYnkgPiBieCkgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIHdlIGhhdmUgY29saW5lYXIgc2VnbWVudHMgd2l0aCBtYXRjaGluZyBvcmllbnRhdGlvblxuICAgIC8vIGNvbnNpZGVyIHRoZSBvbmUgd2l0aCBtb3JlIGxlZnQtbW9yZSByaWdodCBlbmRwb2ludCB0byBiZSBmaXJzdFxuICAgIGlmIChhcnggPiBicngpIHJldHVybiAxO1xuICAgIGlmIChhcnggPCBicngpIHJldHVybiAtMTtcblxuICAgIC8vIGlmIHdlIGdldCBoZXJlLCB0d28gdHdvIHJpZ2h0IGVuZHBvaW50cyBhcmUgaW4gdGhlIHNhbWVcbiAgICAvLyB2ZXJ0aWNhbCBwbGFuZSwgaWUgYXJ4ID09PSBicnhcblxuICAgIC8vIGNvbnNpZGVyIHRoZSBsb3dlciByaWdodC1lbmRwb2ludCB0byBjb21lIGZpcnN0XG4gICAgaWYgKGFyeSA8IGJyeSkgcmV0dXJuIC0xO1xuICAgIGlmIChhcnkgPiBicnkpIHJldHVybiAxO1xuXG4gICAgLy8gcmlnaHQgZW5kcG9pbnRzIGlkZW50aWNhbCBhcyB3ZWxsLCBzbyB0aGUgc2VnbWVudHMgYXJlIGlkZW50aWFsXG4gICAgLy8gZmFsbCBiYWNrIG9uIGNyZWF0aW9uIG9yZGVyIGFzIGNvbnNpc3RlbnQgdGllLWJyZWFrZXJcbiAgICBpZiAoYS5pZCA8IGIuaWQpIHJldHVybiAtMTtcbiAgICBpZiAoYS5pZCA+IGIuaWQpIHJldHVybiAxO1xuXG4gICAgLy8gaWRlbnRpY2FsIHNlZ21lbnQsIGllIGEgPT09IGJcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qIFdhcm5pbmc6IGEgcmVmZXJlbmNlIHRvIHJpbmdXaW5kaW5ncyBpbnB1dCB3aWxsIGJlIHN0b3JlZCxcbiAgICogIGFuZCBwb3NzaWJseSB3aWxsIGJlIGxhdGVyIG1vZGlmaWVkICovXG4gIGNvbnN0cnVjdG9yKGxlZnRTRSwgcmlnaHRTRSwgcmluZ3MsIHdpbmRpbmdzKSB7XG4gICAgdGhpcy5pZCA9ICsrc2VnbWVudElkO1xuICAgIHRoaXMubGVmdFNFID0gbGVmdFNFO1xuICAgIGxlZnRTRS5zZWdtZW50ID0gdGhpcztcbiAgICBsZWZ0U0Uub3RoZXJTRSA9IHJpZ2h0U0U7XG4gICAgdGhpcy5yaWdodFNFID0gcmlnaHRTRTtcbiAgICByaWdodFNFLnNlZ21lbnQgPSB0aGlzO1xuICAgIHJpZ2h0U0Uub3RoZXJTRSA9IGxlZnRTRTtcbiAgICB0aGlzLnJpbmdzID0gcmluZ3M7XG4gICAgdGhpcy53aW5kaW5ncyA9IHdpbmRpbmdzO1xuICAgIC8vIGxlZnQgdW5zZXQgZm9yIHBlcmZvcm1hbmNlLCBzZXQgbGF0ZXIgaW4gYWxnb3JpdGhtXG4gICAgLy8gdGhpcy5yaW5nT3V0LCB0aGlzLmNvbnN1bWVkQnksIHRoaXMucHJldlxuICB9XG4gIHN0YXRpYyBmcm9tUmluZyhwdDEsIHB0MiwgcmluZykge1xuICAgIGxldCBsZWZ0UHQsIHJpZ2h0UHQsIHdpbmRpbmc7XG5cbiAgICAvLyBvcmRlcmluZyB0aGUgdHdvIHBvaW50cyBhY2NvcmRpbmcgdG8gc3dlZXAgbGluZSBvcmRlcmluZ1xuICAgIGNvbnN0IGNtcFB0cyA9IFN3ZWVwRXZlbnQuY29tcGFyZVBvaW50cyhwdDEsIHB0Mik7XG4gICAgaWYgKGNtcFB0cyA8IDApIHtcbiAgICAgIGxlZnRQdCA9IHB0MTtcbiAgICAgIHJpZ2h0UHQgPSBwdDI7XG4gICAgICB3aW5kaW5nID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcFB0cyA+IDApIHtcbiAgICAgIGxlZnRQdCA9IHB0MjtcbiAgICAgIHJpZ2h0UHQgPSBwdDE7XG4gICAgICB3aW5kaW5nID0gLTE7XG4gICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihgVHJpZWQgdG8gY3JlYXRlIGRlZ2VuZXJhdGUgc2VnbWVudCBhdCBbJHtwdDEueH0sICR7cHQxLnl9XWApO1xuICAgIGNvbnN0IGxlZnRTRSA9IG5ldyBTd2VlcEV2ZW50KGxlZnRQdCwgdHJ1ZSk7XG4gICAgY29uc3QgcmlnaHRTRSA9IG5ldyBTd2VlcEV2ZW50KHJpZ2h0UHQsIGZhbHNlKTtcbiAgICByZXR1cm4gbmV3IFNlZ21lbnQobGVmdFNFLCByaWdodFNFLCBbcmluZ10sIFt3aW5kaW5nXSk7XG4gIH1cblxuICAvKiBXaGVuIGEgc2VnbWVudCBpcyBzcGxpdCwgdGhlIHJpZ2h0U0UgaXMgcmVwbGFjZWQgd2l0aCBhIG5ldyBzd2VlcCBldmVudCAqL1xuICByZXBsYWNlUmlnaHRTRShuZXdSaWdodFNFKSB7XG4gICAgdGhpcy5yaWdodFNFID0gbmV3UmlnaHRTRTtcbiAgICB0aGlzLnJpZ2h0U0Uuc2VnbWVudCA9IHRoaXM7XG4gICAgdGhpcy5yaWdodFNFLm90aGVyU0UgPSB0aGlzLmxlZnRTRTtcbiAgICB0aGlzLmxlZnRTRS5vdGhlclNFID0gdGhpcy5yaWdodFNFO1xuICB9XG4gIGJib3goKSB7XG4gICAgY29uc3QgeTEgPSB0aGlzLmxlZnRTRS5wb2ludC55O1xuICAgIGNvbnN0IHkyID0gdGhpcy5yaWdodFNFLnBvaW50Lnk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxsOiB7XG4gICAgICAgIHg6IHRoaXMubGVmdFNFLnBvaW50LngsXG4gICAgICAgIHk6IHkxIDwgeTIgPyB5MSA6IHkyXG4gICAgICB9LFxuICAgICAgdXI6IHtcbiAgICAgICAgeDogdGhpcy5yaWdodFNFLnBvaW50LngsXG4gICAgICAgIHk6IHkxID4geTIgPyB5MSA6IHkyXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qIEEgdmVjdG9yIGZyb20gdGhlIGxlZnQgcG9pbnQgdG8gdGhlIHJpZ2h0ICovXG4gIHZlY3RvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy5yaWdodFNFLnBvaW50LnggLSB0aGlzLmxlZnRTRS5wb2ludC54LFxuICAgICAgeTogdGhpcy5yaWdodFNFLnBvaW50LnkgLSB0aGlzLmxlZnRTRS5wb2ludC55XG4gICAgfTtcbiAgfVxuICBpc0FuRW5kcG9pbnQocHQpIHtcbiAgICByZXR1cm4gcHQueCA9PT0gdGhpcy5sZWZ0U0UucG9pbnQueCAmJiBwdC55ID09PSB0aGlzLmxlZnRTRS5wb2ludC55IHx8IHB0LnggPT09IHRoaXMucmlnaHRTRS5wb2ludC54ICYmIHB0LnkgPT09IHRoaXMucmlnaHRTRS5wb2ludC55O1xuICB9XG5cbiAgLyogQ29tcGFyZSB0aGlzIHNlZ21lbnQgd2l0aCBhIHBvaW50LlxuICAgKlxuICAgKiBBIHBvaW50IFAgaXMgY29uc2lkZXJlZCB0byBiZSBjb2xpbmVhciB0byBhIHNlZ21lbnQgaWYgdGhlcmVcbiAgICogZXhpc3RzIGEgZGlzdGFuY2UgRCBzdWNoIHRoYXQgaWYgd2UgdHJhdmVsIGFsb25nIHRoZSBzZWdtZW50XG4gICAqIGZyb20gb25lICogZW5kcG9pbnQgdG93YXJkcyB0aGUgb3RoZXIgYSBkaXN0YW5jZSBELCB3ZSBmaW5kXG4gICAqIG91cnNlbHZlcyBhdCBwb2ludCBQLlxuICAgKlxuICAgKiBSZXR1cm4gdmFsdWUgaW5kaWNhdGVzOlxuICAgKlxuICAgKiAgIDE6IHBvaW50IGxpZXMgYWJvdmUgdGhlIHNlZ21lbnQgKHRvIHRoZSBsZWZ0IG9mIHZlcnRpY2FsKVxuICAgKiAgIDA6IHBvaW50IGlzIGNvbGluZWFyIHRvIHNlZ21lbnRcbiAgICogIC0xOiBwb2ludCBsaWVzIGJlbG93IHRoZSBzZWdtZW50ICh0byB0aGUgcmlnaHQgb2YgdmVydGljYWwpXG4gICAqL1xuICBjb21wYXJlUG9pbnQocG9pbnQpIHtcbiAgICBpZiAodGhpcy5pc0FuRW5kcG9pbnQocG9pbnQpKSByZXR1cm4gMDtcbiAgICBjb25zdCBsUHQgPSB0aGlzLmxlZnRTRS5wb2ludDtcbiAgICBjb25zdCByUHQgPSB0aGlzLnJpZ2h0U0UucG9pbnQ7XG4gICAgY29uc3QgdiA9IHRoaXMudmVjdG9yKCk7XG5cbiAgICAvLyBFeGFjdGx5IHZlcnRpY2FsIHNlZ21lbnRzLlxuICAgIGlmIChsUHQueCA9PT0gclB0LngpIHtcbiAgICAgIGlmIChwb2ludC54ID09PSBsUHQueCkgcmV0dXJuIDA7XG4gICAgICByZXR1cm4gcG9pbnQueCA8IGxQdC54ID8gMSA6IC0xO1xuICAgIH1cblxuICAgIC8vIE5lYXJseSB2ZXJ0aWNhbCBzZWdtZW50cyB3aXRoIGFuIGludGVyc2VjdGlvbi5cbiAgICAvLyBDaGVjayB0byBzZWUgd2hlcmUgYSBwb2ludCBvbiB0aGUgbGluZSB3aXRoIG1hdGNoaW5nIFkgY29vcmRpbmF0ZSBpcy5cbiAgICBjb25zdCB5RGlzdCA9IChwb2ludC55IC0gbFB0LnkpIC8gdi55O1xuICAgIGNvbnN0IHhGcm9tWURpc3QgPSBsUHQueCArIHlEaXN0ICogdi54O1xuICAgIGlmIChwb2ludC54ID09PSB4RnJvbVlEaXN0KSByZXR1cm4gMDtcblxuICAgIC8vIEdlbmVyYWwgY2FzZS5cbiAgICAvLyBDaGVjayB0byBzZWUgd2hlcmUgYSBwb2ludCBvbiB0aGUgbGluZSB3aXRoIG1hdGNoaW5nIFggY29vcmRpbmF0ZSBpcy5cbiAgICBjb25zdCB4RGlzdCA9IChwb2ludC54IC0gbFB0LngpIC8gdi54O1xuICAgIGNvbnN0IHlGcm9tWERpc3QgPSBsUHQueSArIHhEaXN0ICogdi55O1xuICAgIGlmIChwb2ludC55ID09PSB5RnJvbVhEaXN0KSByZXR1cm4gMDtcbiAgICByZXR1cm4gcG9pbnQueSA8IHlGcm9tWERpc3QgPyAtMSA6IDE7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYW5vdGhlciBzZWdtZW50LCByZXR1cm5zIHRoZSBmaXJzdCBub24tdHJpdmlhbCBpbnRlcnNlY3Rpb25cbiAgICogYmV0d2VlbiB0aGUgdHdvIHNlZ21lbnRzIChpbiB0ZXJtcyBvZiBzd2VlcCBsaW5lIG9yZGVyaW5nKSwgaWYgaXQgZXhpc3RzLlxuICAgKlxuICAgKiBBICdub24tdHJpdmlhbCcgaW50ZXJzZWN0aW9uIGlzIG9uZSB0aGF0IHdpbGwgY2F1c2Ugb25lIG9yIGJvdGggb2YgdGhlXG4gICAqIHNlZ21lbnRzIHRvIGJlIHNwbGl0KCkuIEFzIHN1Y2gsICd0cml2aWFsJyB2cy4gJ25vbi10cml2aWFsJyBpbnRlcnNlY3Rpb246XG4gICAqXG4gICAqICAgKiBlbmRwb2ludCBvZiBzZWdBIHdpdGggZW5kcG9pbnQgb2Ygc2VnQiAtLT4gdHJpdmlhbFxuICAgKiAgICogZW5kcG9pbnQgb2Ygc2VnQSB3aXRoIHBvaW50IGFsb25nIHNlZ0IgLS0+IG5vbi10cml2aWFsXG4gICAqICAgKiBlbmRwb2ludCBvZiBzZWdCIHdpdGggcG9pbnQgYWxvbmcgc2VnQSAtLT4gbm9uLXRyaXZpYWxcbiAgICogICAqIHBvaW50IGFsb25nIHNlZ0Egd2l0aCBwb2ludCBhbG9uZyBzZWdCIC0tPiBub24tdHJpdmlhbFxuICAgKlxuICAgKiBJZiBubyBub24tdHJpdmlhbCBpbnRlcnNlY3Rpb24gZXhpc3RzLCByZXR1cm4gbnVsbFxuICAgKiBFbHNlLCByZXR1cm4gbnVsbC5cbiAgICovXG4gIGdldEludGVyc2VjdGlvbihvdGhlcikge1xuICAgIC8vIElmIGJib3hlcyBkb24ndCBvdmVybGFwLCB0aGVyZSBjYW4ndCBiZSBhbnkgaW50ZXJzZWN0aW9uc1xuICAgIGNvbnN0IHRCYm94ID0gdGhpcy5iYm94KCk7XG4gICAgY29uc3Qgb0Jib3ggPSBvdGhlci5iYm94KCk7XG4gICAgY29uc3QgYmJveE92ZXJsYXAgPSBnZXRCYm94T3ZlcmxhcCh0QmJveCwgb0Jib3gpO1xuICAgIGlmIChiYm94T3ZlcmxhcCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBXZSBmaXJzdCBjaGVjayB0byBzZWUgaWYgdGhlIGVuZHBvaW50cyBjYW4gYmUgY29uc2lkZXJlZCBpbnRlcnNlY3Rpb25zLlxuICAgIC8vIFRoaXMgd2lsbCAnc25hcCcgaW50ZXJzZWN0aW9ucyB0byBlbmRwb2ludHMgaWYgcG9zc2libGUsIGFuZCB3aWxsXG4gICAgLy8gaGFuZGxlIGNhc2VzIG9mIGNvbGluZWFyaXR5LlxuXG4gICAgY29uc3QgdGxwID0gdGhpcy5sZWZ0U0UucG9pbnQ7XG4gICAgY29uc3QgdHJwID0gdGhpcy5yaWdodFNFLnBvaW50O1xuICAgIGNvbnN0IG9scCA9IG90aGVyLmxlZnRTRS5wb2ludDtcbiAgICBjb25zdCBvcnAgPSBvdGhlci5yaWdodFNFLnBvaW50O1xuXG4gICAgLy8gZG9lcyBlYWNoIGVuZHBvaW50IHRvdWNoIHRoZSBvdGhlciBzZWdtZW50P1xuICAgIC8vIG5vdGUgdGhhdCB3ZSByZXN0cmljdCB0aGUgJ3RvdWNoaW5nJyBkZWZpbml0aW9uIHRvIG9ubHkgYWxsb3cgc2VnbWVudHNcbiAgICAvLyB0byB0b3VjaCBlbmRwb2ludHMgdGhhdCBsaWUgZm9yd2FyZCBmcm9tIHdoZXJlIHdlIGFyZSBpbiB0aGUgc3dlZXAgbGluZSBwYXNzXG4gICAgY29uc3QgdG91Y2hlc090aGVyTFNFID0gaXNJbkJib3godEJib3gsIG9scCkgJiYgdGhpcy5jb21wYXJlUG9pbnQob2xwKSA9PT0gMDtcbiAgICBjb25zdCB0b3VjaGVzVGhpc0xTRSA9IGlzSW5CYm94KG9CYm94LCB0bHApICYmIG90aGVyLmNvbXBhcmVQb2ludCh0bHApID09PSAwO1xuICAgIGNvbnN0IHRvdWNoZXNPdGhlclJTRSA9IGlzSW5CYm94KHRCYm94LCBvcnApICYmIHRoaXMuY29tcGFyZVBvaW50KG9ycCkgPT09IDA7XG4gICAgY29uc3QgdG91Y2hlc1RoaXNSU0UgPSBpc0luQmJveChvQmJveCwgdHJwKSAmJiBvdGhlci5jb21wYXJlUG9pbnQodHJwKSA9PT0gMDtcblxuICAgIC8vIGRvIGxlZnQgZW5kcG9pbnRzIG1hdGNoP1xuICAgIGlmICh0b3VjaGVzVGhpc0xTRSAmJiB0b3VjaGVzT3RoZXJMU0UpIHtcbiAgICAgIC8vIHRoZXNlIHR3byBjYXNlcyBhcmUgZm9yIGNvbGluZWFyIHNlZ21lbnRzIHdpdGggbWF0Y2hpbmcgbGVmdFxuICAgICAgLy8gZW5kcG9pbnRzLCBhbmQgb25lIHNlZ21lbnQgYmVpbmcgbG9uZ2VyIHRoYW4gdGhlIG90aGVyXG4gICAgICBpZiAodG91Y2hlc1RoaXNSU0UgJiYgIXRvdWNoZXNPdGhlclJTRSkgcmV0dXJuIHRycDtcbiAgICAgIGlmICghdG91Y2hlc1RoaXNSU0UgJiYgdG91Y2hlc090aGVyUlNFKSByZXR1cm4gb3JwO1xuICAgICAgLy8gZWl0aGVyIHRoZSB0d28gc2VnbWVudHMgbWF0Y2ggZXhhY3RseSAodHdvIHRyaXZhbCBpbnRlcnNlY3Rpb25zKVxuICAgICAgLy8gb3IganVzdCBvbiB0aGVpciBsZWZ0IGVuZHBvaW50IChvbmUgdHJpdmlhbCBpbnRlcnNlY3Rpb25cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGRvZXMgdGhpcyBsZWZ0IGVuZHBvaW50IG1hdGNoZXMgKG90aGVyIGRvZXNuJ3QpXG4gICAgaWYgKHRvdWNoZXNUaGlzTFNFKSB7XG4gICAgICAvLyBjaGVjayBmb3Igc2VnbWVudHMgdGhhdCBqdXN0IGludGVyc2VjdCBvbiBvcHBvc2luZyBlbmRwb2ludHNcbiAgICAgIGlmICh0b3VjaGVzT3RoZXJSU0UpIHtcbiAgICAgICAgaWYgKHRscC54ID09PSBvcnAueCAmJiB0bHAueSA9PT0gb3JwLnkpIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gdC1pbnRlcnNlY3Rpb24gb24gbGVmdCBlbmRwb2ludFxuICAgICAgcmV0dXJuIHRscDtcbiAgICB9XG5cbiAgICAvLyBkb2VzIG90aGVyIGxlZnQgZW5kcG9pbnQgbWF0Y2hlcyAodGhpcyBkb2Vzbid0KVxuICAgIGlmICh0b3VjaGVzT3RoZXJMU0UpIHtcbiAgICAgIC8vIGNoZWNrIGZvciBzZWdtZW50cyB0aGF0IGp1c3QgaW50ZXJzZWN0IG9uIG9wcG9zaW5nIGVuZHBvaW50c1xuICAgICAgaWYgKHRvdWNoZXNUaGlzUlNFKSB7XG4gICAgICAgIGlmICh0cnAueCA9PT0gb2xwLnggJiYgdHJwLnkgPT09IG9scC55KSByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIHQtaW50ZXJzZWN0aW9uIG9uIGxlZnQgZW5kcG9pbnRcbiAgICAgIHJldHVybiBvbHA7XG4gICAgfVxuXG4gICAgLy8gdHJpdmlhbCBpbnRlcnNlY3Rpb24gb24gcmlnaHQgZW5kcG9pbnRzXG4gICAgaWYgKHRvdWNoZXNUaGlzUlNFICYmIHRvdWNoZXNPdGhlclJTRSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyB0LWludGVyc2VjdGlvbnMgb24ganVzdCBvbmUgcmlnaHQgZW5kcG9pbnRcbiAgICBpZiAodG91Y2hlc1RoaXNSU0UpIHJldHVybiB0cnA7XG4gICAgaWYgKHRvdWNoZXNPdGhlclJTRSkgcmV0dXJuIG9ycDtcblxuICAgIC8vIE5vbmUgb2Ygb3VyIGVuZHBvaW50cyBpbnRlcnNlY3QuIExvb2sgZm9yIGEgZ2VuZXJhbCBpbnRlcnNlY3Rpb24gYmV0d2VlblxuICAgIC8vIGluZmluaXRlIGxpbmVzIGxhaWQgb3ZlciB0aGUgc2VnbWVudHNcbiAgICBjb25zdCBwdCA9IGludGVyc2VjdGlvbiQxKHRscCwgdGhpcy52ZWN0b3IoKSwgb2xwLCBvdGhlci52ZWN0b3IoKSk7XG5cbiAgICAvLyBhcmUgdGhlIHNlZ21lbnRzIHBhcnJhbGxlbD8gTm90ZSB0aGF0IGlmIHRoZXkgd2VyZSBjb2xpbmVhciB3aXRoIG92ZXJsYXAsXG4gICAgLy8gdGhleSB3b3VsZCBoYXZlIGFuIGVuZHBvaW50IGludGVyc2VjdGlvbiBhbmQgdGhhdCBjYXNlIHdhcyBhbHJlYWR5IGhhbmRsZWQgYWJvdmVcbiAgICBpZiAocHQgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgLy8gaXMgdGhlIGludGVyc2VjdGlvbiBmb3VuZCBiZXR3ZWVuIHRoZSBsaW5lcyBub3Qgb24gdGhlIHNlZ21lbnRzP1xuICAgIGlmICghaXNJbkJib3goYmJveE92ZXJsYXAsIHB0KSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyByb3VuZCB0aGUgdGhlIGNvbXB1dGVkIHBvaW50IGlmIG5lZWRlZFxuICAgIHJldHVybiByb3VuZGVyLnJvdW5kKHB0LngsIHB0LnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoZSBnaXZlbiBzZWdtZW50IGludG8gbXVsdGlwbGUgc2VnbWVudHMgb24gdGhlIGdpdmVuIHBvaW50cy5cbiAgICogICogRWFjaCBleGlzdGluZyBzZWdtZW50IHdpbGwgcmV0YWluIGl0cyBsZWZ0U0UgYW5kIGEgbmV3IHJpZ2h0U0Ugd2lsbCBiZVxuICAgKiAgICBnZW5lcmF0ZWQgZm9yIGl0LlxuICAgKiAgKiBBIG5ldyBzZWdtZW50IHdpbGwgYmUgZ2VuZXJhdGVkIHdoaWNoIHdpbGwgYWRvcHQgdGhlIG9yaWdpbmFsIHNlZ21lbnQnc1xuICAgKiAgICByaWdodFNFLCBhbmQgYSBuZXcgbGVmdFNFIHdpbGwgYmUgZ2VuZXJhdGVkIGZvciBpdC5cbiAgICogICogSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiB0d28gcG9pbnRzIGdpdmVuIHRvIHNwbGl0IG9uLCBuZXcgc2VnbWVudHNcbiAgICogICAgaW4gdGhlIG1pZGRsZSB3aWxsIGJlIGdlbmVyYXRlZCB3aXRoIG5ldyBsZWZ0U0UgYW5kIHJpZ2h0U0Uncy5cbiAgICogICogQW4gYXJyYXkgb2YgdGhlIG5ld2x5IGdlbmVyYXRlZCBTd2VlcEV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBXYXJuaW5nOiBpbnB1dCBhcnJheSBvZiBwb2ludHMgaXMgbW9kaWZpZWRcbiAgICovXG4gIHNwbGl0KHBvaW50KSB7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gW107XG4gICAgY29uc3QgYWxyZWFkeUxpbmtlZCA9IHBvaW50LmV2ZW50cyAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5ld0xlZnRTRSA9IG5ldyBTd2VlcEV2ZW50KHBvaW50LCB0cnVlKTtcbiAgICBjb25zdCBuZXdSaWdodFNFID0gbmV3IFN3ZWVwRXZlbnQocG9pbnQsIGZhbHNlKTtcbiAgICBjb25zdCBvbGRSaWdodFNFID0gdGhpcy5yaWdodFNFO1xuICAgIHRoaXMucmVwbGFjZVJpZ2h0U0UobmV3UmlnaHRTRSk7XG4gICAgbmV3RXZlbnRzLnB1c2gobmV3UmlnaHRTRSk7XG4gICAgbmV3RXZlbnRzLnB1c2gobmV3TGVmdFNFKTtcbiAgICBjb25zdCBuZXdTZWcgPSBuZXcgU2VnbWVudChuZXdMZWZ0U0UsIG9sZFJpZ2h0U0UsIHRoaXMucmluZ3Muc2xpY2UoKSwgdGhpcy53aW5kaW5ncy5zbGljZSgpKTtcblxuICAgIC8vIHdoZW4gc3BsaXR0aW5nIGEgbmVhcmx5IHZlcnRpY2FsIGRvd253YXJkLWZhY2luZyBzZWdtZW50LFxuICAgIC8vIHNvbWV0aW1lcyBvbmUgb2YgdGhlIHJlc3VsdGluZyBuZXcgc2VnbWVudHMgaXMgdmVydGljYWwsIGluIHdoaWNoXG4gICAgLy8gY2FzZSBpdHMgbGVmdCBhbmQgcmlnaHQgZXZlbnRzIG1heSBuZWVkIHRvIGJlIHN3YXBwZWRcbiAgICBpZiAoU3dlZXBFdmVudC5jb21wYXJlUG9pbnRzKG5ld1NlZy5sZWZ0U0UucG9pbnQsIG5ld1NlZy5yaWdodFNFLnBvaW50KSA+IDApIHtcbiAgICAgIG5ld1NlZy5zd2FwRXZlbnRzKCk7XG4gICAgfVxuICAgIGlmIChTd2VlcEV2ZW50LmNvbXBhcmVQb2ludHModGhpcy5sZWZ0U0UucG9pbnQsIHRoaXMucmlnaHRTRS5wb2ludCkgPiAwKSB7XG4gICAgICB0aGlzLnN3YXBFdmVudHMoKTtcbiAgICB9XG5cbiAgICAvLyBpbiB0aGUgcG9pbnQgd2UganVzdCB1c2VkIHRvIGNyZWF0ZSBuZXcgc3dlZXAgZXZlbnRzIHdpdGggd2FzIGFscmVhZHlcbiAgICAvLyBsaW5rZWQgdG8gb3RoZXIgZXZlbnRzLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIGVpdGhlciBvZiB0aGUgYWZmZWN0ZWRcbiAgICAvLyBzZWdtZW50cyBzaG91bGQgYmUgY29uc3VtZWRcbiAgICBpZiAoYWxyZWFkeUxpbmtlZCkge1xuICAgICAgbmV3TGVmdFNFLmNoZWNrRm9yQ29uc3VtaW5nKCk7XG4gICAgICBuZXdSaWdodFNFLmNoZWNrRm9yQ29uc3VtaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdFdmVudHM7XG4gIH1cblxuICAvKiBTd2FwIHdoaWNoIGV2ZW50IGlzIGxlZnQgYW5kIHJpZ2h0ICovXG4gIHN3YXBFdmVudHMoKSB7XG4gICAgY29uc3QgdG1wRXZ0ID0gdGhpcy5yaWdodFNFO1xuICAgIHRoaXMucmlnaHRTRSA9IHRoaXMubGVmdFNFO1xuICAgIHRoaXMubGVmdFNFID0gdG1wRXZ0O1xuICAgIHRoaXMubGVmdFNFLmlzTGVmdCA9IHRydWU7XG4gICAgdGhpcy5yaWdodFNFLmlzTGVmdCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gdGhpcy53aW5kaW5ncy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIHRoaXMud2luZGluZ3NbaV0gKj0gLTE7XG4gICAgfVxuICB9XG5cbiAgLyogQ29uc3VtZSBhbm90aGVyIHNlZ21lbnQuIFdlIHRha2UgdGhlaXIgcmluZ3MgdW5kZXIgb3VyIHdpbmdcbiAgICogYW5kIG1hcmsgdGhlbSBhcyBjb25zdW1lZC4gVXNlIGZvciBwZXJmZWN0bHkgb3ZlcmxhcHBpbmcgc2VnbWVudHMgKi9cbiAgY29uc3VtZShvdGhlcikge1xuICAgIGxldCBjb25zdW1lciA9IHRoaXM7XG4gICAgbGV0IGNvbnN1bWVlID0gb3RoZXI7XG4gICAgd2hpbGUgKGNvbnN1bWVyLmNvbnN1bWVkQnkpIGNvbnN1bWVyID0gY29uc3VtZXIuY29uc3VtZWRCeTtcbiAgICB3aGlsZSAoY29uc3VtZWUuY29uc3VtZWRCeSkgY29uc3VtZWUgPSBjb25zdW1lZS5jb25zdW1lZEJ5O1xuICAgIGNvbnN0IGNtcCA9IFNlZ21lbnQuY29tcGFyZShjb25zdW1lciwgY29uc3VtZWUpO1xuICAgIGlmIChjbXAgPT09IDApIHJldHVybjsgLy8gYWxyZWFkeSBjb25zdW1lZFxuICAgIC8vIHRoZSB3aW5uZXIgb2YgdGhlIGNvbnN1bXB0aW9uIGlzIHRoZSBlYXJsaWVyIHNlZ21lbnRcbiAgICAvLyBhY2NvcmRpbmcgdG8gc3dlZXAgbGluZSBvcmRlcmluZ1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBjb25zdCB0bXAgPSBjb25zdW1lcjtcbiAgICAgIGNvbnN1bWVyID0gY29uc3VtZWU7XG4gICAgICBjb25zdW1lZSA9IHRtcDtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgYSBzZWdtZW50IGRvZXNuJ3QgY29uc3VtZSBpdCdzIHByZXZcbiAgICBpZiAoY29uc3VtZXIucHJldiA9PT0gY29uc3VtZWUpIHtcbiAgICAgIGNvbnN0IHRtcCA9IGNvbnN1bWVyO1xuICAgICAgY29uc3VtZXIgPSBjb25zdW1lZTtcbiAgICAgIGNvbnN1bWVlID0gdG1wO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IGNvbnN1bWVlLnJpbmdzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgcmluZyA9IGNvbnN1bWVlLnJpbmdzW2ldO1xuICAgICAgY29uc3Qgd2luZGluZyA9IGNvbnN1bWVlLndpbmRpbmdzW2ldO1xuICAgICAgY29uc3QgaW5kZXggPSBjb25zdW1lci5yaW5ncy5pbmRleE9mKHJpbmcpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBjb25zdW1lci5yaW5ncy5wdXNoKHJpbmcpO1xuICAgICAgICBjb25zdW1lci53aW5kaW5ncy5wdXNoKHdpbmRpbmcpO1xuICAgICAgfSBlbHNlIGNvbnN1bWVyLndpbmRpbmdzW2luZGV4XSArPSB3aW5kaW5nO1xuICAgIH1cbiAgICBjb25zdW1lZS5yaW5ncyA9IG51bGw7XG4gICAgY29uc3VtZWUud2luZGluZ3MgPSBudWxsO1xuICAgIGNvbnN1bWVlLmNvbnN1bWVkQnkgPSBjb25zdW1lcjtcblxuICAgIC8vIG1hcmsgc3dlZXAgZXZlbnRzIGNvbnN1bWVkIGFzIHRvIG1haW50YWluIG9yZGVyaW5nIGluIHN3ZWVwIGV2ZW50IHF1ZXVlXG4gICAgY29uc3VtZWUubGVmdFNFLmNvbnN1bWVkQnkgPSBjb25zdW1lci5sZWZ0U0U7XG4gICAgY29uc3VtZWUucmlnaHRTRS5jb25zdW1lZEJ5ID0gY29uc3VtZXIucmlnaHRTRTtcbiAgfVxuXG4gIC8qIFRoZSBmaXJzdCBzZWdtZW50IHByZXZpb3VzIHNlZ21lbnQgY2hhaW4gdGhhdCBpcyBpbiB0aGUgcmVzdWx0ICovXG4gIHByZXZJblJlc3VsdCgpIHtcbiAgICBpZiAodGhpcy5fcHJldkluUmVzdWx0ICE9PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLl9wcmV2SW5SZXN1bHQ7XG4gICAgaWYgKCF0aGlzLnByZXYpIHRoaXMuX3ByZXZJblJlc3VsdCA9IG51bGw7ZWxzZSBpZiAodGhpcy5wcmV2LmlzSW5SZXN1bHQoKSkgdGhpcy5fcHJldkluUmVzdWx0ID0gdGhpcy5wcmV2O2Vsc2UgdGhpcy5fcHJldkluUmVzdWx0ID0gdGhpcy5wcmV2LnByZXZJblJlc3VsdCgpO1xuICAgIHJldHVybiB0aGlzLl9wcmV2SW5SZXN1bHQ7XG4gIH1cbiAgYmVmb3JlU3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2JlZm9yZVN0YXRlICE9PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLl9iZWZvcmVTdGF0ZTtcbiAgICBpZiAoIXRoaXMucHJldikgdGhpcy5fYmVmb3JlU3RhdGUgPSB7XG4gICAgICByaW5nczogW10sXG4gICAgICB3aW5kaW5nczogW10sXG4gICAgICBtdWx0aVBvbHlzOiBbXVxuICAgIH07ZWxzZSB7XG4gICAgICBjb25zdCBzZWcgPSB0aGlzLnByZXYuY29uc3VtZWRCeSB8fCB0aGlzLnByZXY7XG4gICAgICB0aGlzLl9iZWZvcmVTdGF0ZSA9IHNlZy5hZnRlclN0YXRlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9iZWZvcmVTdGF0ZTtcbiAgfVxuICBhZnRlclN0YXRlKCkge1xuICAgIGlmICh0aGlzLl9hZnRlclN0YXRlICE9PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLl9hZnRlclN0YXRlO1xuICAgIGNvbnN0IGJlZm9yZVN0YXRlID0gdGhpcy5iZWZvcmVTdGF0ZSgpO1xuICAgIHRoaXMuX2FmdGVyU3RhdGUgPSB7XG4gICAgICByaW5nczogYmVmb3JlU3RhdGUucmluZ3Muc2xpY2UoMCksXG4gICAgICB3aW5kaW5nczogYmVmb3JlU3RhdGUud2luZGluZ3Muc2xpY2UoMCksXG4gICAgICBtdWx0aVBvbHlzOiBbXVxuICAgIH07XG4gICAgY29uc3QgcmluZ3NBZnRlciA9IHRoaXMuX2FmdGVyU3RhdGUucmluZ3M7XG4gICAgY29uc3Qgd2luZGluZ3NBZnRlciA9IHRoaXMuX2FmdGVyU3RhdGUud2luZGluZ3M7XG4gICAgY29uc3QgbXBzQWZ0ZXIgPSB0aGlzLl9hZnRlclN0YXRlLm11bHRpUG9seXM7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmluZ3NBZnRlciwgd2luZGluZ3NBZnRlclxuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gdGhpcy5yaW5ncy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHJpbmcgPSB0aGlzLnJpbmdzW2ldO1xuICAgICAgY29uc3Qgd2luZGluZyA9IHRoaXMud2luZGluZ3NbaV07XG4gICAgICBjb25zdCBpbmRleCA9IHJpbmdzQWZ0ZXIuaW5kZXhPZihyaW5nKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmluZ3NBZnRlci5wdXNoKHJpbmcpO1xuICAgICAgICB3aW5kaW5nc0FmdGVyLnB1c2god2luZGluZyk7XG4gICAgICB9IGVsc2Ugd2luZGluZ3NBZnRlcltpbmRleF0gKz0gd2luZGluZztcbiAgICB9XG5cbiAgICAvLyBjYWxjdWFsdGUgcG9seXNBZnRlclxuICAgIGNvbnN0IHBvbHlzQWZ0ZXIgPSBbXTtcbiAgICBjb25zdCBwb2x5c0V4Y2x1ZGUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHJpbmdzQWZ0ZXIubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBpZiAod2luZGluZ3NBZnRlcltpXSA9PT0gMCkgY29udGludWU7IC8vIG5vbi16ZXJvIHJ1bGVcbiAgICAgIGNvbnN0IHJpbmcgPSByaW5nc0FmdGVyW2ldO1xuICAgICAgY29uc3QgcG9seSA9IHJpbmcucG9seTtcbiAgICAgIGlmIChwb2x5c0V4Y2x1ZGUuaW5kZXhPZihwb2x5KSAhPT0gLTEpIGNvbnRpbnVlO1xuICAgICAgaWYgKHJpbmcuaXNFeHRlcmlvcikgcG9seXNBZnRlci5wdXNoKHBvbHkpO2Vsc2Uge1xuICAgICAgICBpZiAocG9seXNFeGNsdWRlLmluZGV4T2YocG9seSkgPT09IC0xKSBwb2x5c0V4Y2x1ZGUucHVzaChwb2x5KTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwb2x5c0FmdGVyLmluZGV4T2YocmluZy5wb2x5KTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkgcG9seXNBZnRlci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBtdWx0aVBvbHlzQWZ0ZXJcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHBvbHlzQWZ0ZXIubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCBtcCA9IHBvbHlzQWZ0ZXJbaV0ubXVsdGlQb2x5O1xuICAgICAgaWYgKG1wc0FmdGVyLmluZGV4T2YobXApID09PSAtMSkgbXBzQWZ0ZXIucHVzaChtcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZnRlclN0YXRlO1xuICB9XG5cbiAgLyogSXMgdGhpcyBzZWdtZW50IHBhcnQgb2YgdGhlIGZpbmFsIHJlc3VsdD8gKi9cbiAgaXNJblJlc3VsdCgpIHtcbiAgICAvLyBpZiB3ZSd2ZSBiZWVuIGNvbnN1bWVkLCB3ZSdyZSBub3QgaW4gdGhlIHJlc3VsdFxuICAgIGlmICh0aGlzLmNvbnN1bWVkQnkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5faXNJblJlc3VsdCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5faXNJblJlc3VsdDtcbiAgICBjb25zdCBtcHNCZWZvcmUgPSB0aGlzLmJlZm9yZVN0YXRlKCkubXVsdGlQb2x5cztcbiAgICBjb25zdCBtcHNBZnRlciA9IHRoaXMuYWZ0ZXJTdGF0ZSgpLm11bHRpUG9seXM7XG4gICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkge1xuICAgICAgY2FzZSBcInVuaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBVTklPTiAtIGluY2x1ZGVkIGlmZjpcbiAgICAgICAgICAvLyAgKiBPbiBvbmUgc2lkZSBvZiB1cyB0aGVyZSBpcyAwIHBvbHkgaW50ZXJpb3JzIEFORFxuICAgICAgICAgIC8vICAqIE9uIHRoZSBvdGhlciBzaWRlIHRoZXJlIGlzIDEgb3IgbW9yZS5cbiAgICAgICAgICBjb25zdCBub0JlZm9yZXMgPSBtcHNCZWZvcmUubGVuZ3RoID09PSAwO1xuICAgICAgICAgIGNvbnN0IG5vQWZ0ZXJzID0gbXBzQWZ0ZXIubGVuZ3RoID09PSAwO1xuICAgICAgICAgIHRoaXMuX2lzSW5SZXN1bHQgPSBub0JlZm9yZXMgIT09IG5vQWZ0ZXJzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiaW50ZXJzZWN0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBJTlRFUlNFQ1RJT04gLSBpbmNsdWRlZCBpZmY6XG4gICAgICAgICAgLy8gICogb24gb25lIHNpZGUgb2YgdXMgYWxsIG11bHRpcG9seXMgYXJlIHJlcC4gd2l0aCBwb2x5IGludGVyaW9ycyBBTkRcbiAgICAgICAgICAvLyAgKiBvbiB0aGUgb3RoZXIgc2lkZSBvZiB1cywgbm90IGFsbCBtdWx0aXBvbHlzIGFyZSByZXBzZW50ZWRcbiAgICAgICAgICAvLyAgICB3aXRoIHBvbHkgaW50ZXJpb3JzXG4gICAgICAgICAgbGV0IGxlYXN0O1xuICAgICAgICAgIGxldCBtb3N0O1xuICAgICAgICAgIGlmIChtcHNCZWZvcmUubGVuZ3RoIDwgbXBzQWZ0ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZWFzdCA9IG1wc0JlZm9yZS5sZW5ndGg7XG4gICAgICAgICAgICBtb3N0ID0gbXBzQWZ0ZXIubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWFzdCA9IG1wc0FmdGVyLmxlbmd0aDtcbiAgICAgICAgICAgIG1vc3QgPSBtcHNCZWZvcmUubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9pc0luUmVzdWx0ID0gbW9zdCA9PT0gb3BlcmF0aW9uLm51bU11bHRpUG9seXMgJiYgbGVhc3QgPCBtb3N0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwieG9yXCI6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBYT1IgLSBpbmNsdWRlZCBpZmY6XG4gICAgICAgICAgLy8gICogdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbnVtYmVyIG9mIG11bHRpcG9seXMgcmVwcmVzZW50ZWRcbiAgICAgICAgICAvLyAgICB3aXRoIHBvbHkgaW50ZXJpb3JzIG9uIG91ciB0d28gc2lkZXMgaXMgYW4gb2RkIG51bWJlclxuICAgICAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhtcHNCZWZvcmUubGVuZ3RoIC0gbXBzQWZ0ZXIubGVuZ3RoKTtcbiAgICAgICAgICB0aGlzLl9pc0luUmVzdWx0ID0gZGlmZiAlIDIgPT09IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJkaWZmZXJlbmNlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBESUZGRVJFTkNFIGluY2x1ZGVkIGlmZjpcbiAgICAgICAgICAvLyAgKiBvbiBleGFjdGx5IG9uZSBzaWRlLCB3ZSBoYXZlIGp1c3QgdGhlIHN1YmplY3RcbiAgICAgICAgICBjb25zdCBpc0p1c3RTdWJqZWN0ID0gbXBzID0+IG1wcy5sZW5ndGggPT09IDEgJiYgbXBzWzBdLmlzU3ViamVjdDtcbiAgICAgICAgICB0aGlzLl9pc0luUmVzdWx0ID0gaXNKdXN0U3ViamVjdChtcHNCZWZvcmUpICE9PSBpc0p1c3RTdWJqZWN0KG1wc0FmdGVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgb3BlcmF0aW9uIHR5cGUgZm91bmQgJHtvcGVyYXRpb24udHlwZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2lzSW5SZXN1bHQ7XG4gIH1cbn1cblxuY2xhc3MgUmluZ0luIHtcbiAgY29uc3RydWN0b3IoZ2VvbVJpbmcsIHBvbHksIGlzRXh0ZXJpb3IpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZ2VvbVJpbmcpIHx8IGdlb21SaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZ2VvbWV0cnkgaXMgbm90IGEgdmFsaWQgUG9seWdvbiBvciBNdWx0aVBvbHlnb25cIik7XG4gICAgfVxuICAgIHRoaXMucG9seSA9IHBvbHk7XG4gICAgdGhpcy5pc0V4dGVyaW9yID0gaXNFeHRlcmlvcjtcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgaWYgKHR5cGVvZiBnZW9tUmluZ1swXVswXSAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZ2VvbVJpbmdbMF1bMV0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGdlb21ldHJ5IGlzIG5vdCBhIHZhbGlkIFBvbHlnb24gb3IgTXVsdGlQb2x5Z29uXCIpO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gcm91bmRlci5yb3VuZChnZW9tUmluZ1swXVswXSwgZ2VvbVJpbmdbMF1bMV0pO1xuICAgIHRoaXMuYmJveCA9IHtcbiAgICAgIGxsOiB7XG4gICAgICAgIHg6IGZpcnN0UG9pbnQueCxcbiAgICAgICAgeTogZmlyc3RQb2ludC55XG4gICAgICB9LFxuICAgICAgdXI6IHtcbiAgICAgICAgeDogZmlyc3RQb2ludC54LFxuICAgICAgICB5OiBmaXJzdFBvaW50LnlcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBwcmV2UG9pbnQgPSBmaXJzdFBvaW50O1xuICAgIGZvciAobGV0IGkgPSAxLCBpTWF4ID0gZ2VvbVJpbmcubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGdlb21SaW5nW2ldWzBdICE9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBnZW9tUmluZ1tpXVsxXSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBnZW9tZXRyeSBpcyBub3QgYSB2YWxpZCBQb2x5Z29uIG9yIE11bHRpUG9seWdvblwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBwb2ludCA9IHJvdW5kZXIucm91bmQoZ2VvbVJpbmdbaV1bMF0sIGdlb21SaW5nW2ldWzFdKTtcbiAgICAgIC8vIHNraXAgcmVwZWF0ZWQgcG9pbnRzXG4gICAgICBpZiAocG9pbnQueCA9PT0gcHJldlBvaW50LnggJiYgcG9pbnQueSA9PT0gcHJldlBvaW50LnkpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKFNlZ21lbnQuZnJvbVJpbmcocHJldlBvaW50LCBwb2ludCwgdGhpcykpO1xuICAgICAgaWYgKHBvaW50LnggPCB0aGlzLmJib3gubGwueCkgdGhpcy5iYm94LmxsLnggPSBwb2ludC54O1xuICAgICAgaWYgKHBvaW50LnkgPCB0aGlzLmJib3gubGwueSkgdGhpcy5iYm94LmxsLnkgPSBwb2ludC55O1xuICAgICAgaWYgKHBvaW50LnggPiB0aGlzLmJib3gudXIueCkgdGhpcy5iYm94LnVyLnggPSBwb2ludC54O1xuICAgICAgaWYgKHBvaW50LnkgPiB0aGlzLmJib3gudXIueSkgdGhpcy5iYm94LnVyLnkgPSBwb2ludC55O1xuICAgICAgcHJldlBvaW50ID0gcG9pbnQ7XG4gICAgfVxuICAgIC8vIGFkZCBzZWdtZW50IGZyb20gbGFzdCB0byBmaXJzdCBpZiBsYXN0IGlzIG5vdCB0aGUgc2FtZSBhcyBmaXJzdFxuICAgIGlmIChmaXJzdFBvaW50LnggIT09IHByZXZQb2ludC54IHx8IGZpcnN0UG9pbnQueSAhPT0gcHJldlBvaW50LnkpIHtcbiAgICAgIHRoaXMuc2VnbWVudHMucHVzaChTZWdtZW50LmZyb21SaW5nKHByZXZQb2ludCwgZmlyc3RQb2ludCwgdGhpcykpO1xuICAgIH1cbiAgfVxuICBnZXRTd2VlcEV2ZW50cygpIHtcbiAgICBjb25zdCBzd2VlcEV2ZW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gdGhpcy5zZWdtZW50cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHNlZ21lbnQgPSB0aGlzLnNlZ21lbnRzW2ldO1xuICAgICAgc3dlZXBFdmVudHMucHVzaChzZWdtZW50LmxlZnRTRSk7XG4gICAgICBzd2VlcEV2ZW50cy5wdXNoKHNlZ21lbnQucmlnaHRTRSk7XG4gICAgfVxuICAgIHJldHVybiBzd2VlcEV2ZW50cztcbiAgfVxufVxuY2xhc3MgUG9seUluIHtcbiAgY29uc3RydWN0b3IoZ2VvbVBvbHksIG11bHRpUG9seSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShnZW9tUG9seSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGdlb21ldHJ5IGlzIG5vdCBhIHZhbGlkIFBvbHlnb24gb3IgTXVsdGlQb2x5Z29uXCIpO1xuICAgIH1cbiAgICB0aGlzLmV4dGVyaW9yUmluZyA9IG5ldyBSaW5nSW4oZ2VvbVBvbHlbMF0sIHRoaXMsIHRydWUpO1xuICAgIC8vIGNvcHkgYnkgdmFsdWVcbiAgICB0aGlzLmJib3ggPSB7XG4gICAgICBsbDoge1xuICAgICAgICB4OiB0aGlzLmV4dGVyaW9yUmluZy5iYm94LmxsLngsXG4gICAgICAgIHk6IHRoaXMuZXh0ZXJpb3JSaW5nLmJib3gubGwueVxuICAgICAgfSxcbiAgICAgIHVyOiB7XG4gICAgICAgIHg6IHRoaXMuZXh0ZXJpb3JSaW5nLmJib3gudXIueCxcbiAgICAgICAgeTogdGhpcy5leHRlcmlvclJpbmcuYmJveC51ci55XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmludGVyaW9yUmluZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMSwgaU1heCA9IGdlb21Qb2x5Lmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgcmluZyA9IG5ldyBSaW5nSW4oZ2VvbVBvbHlbaV0sIHRoaXMsIGZhbHNlKTtcbiAgICAgIGlmIChyaW5nLmJib3gubGwueCA8IHRoaXMuYmJveC5sbC54KSB0aGlzLmJib3gubGwueCA9IHJpbmcuYmJveC5sbC54O1xuICAgICAgaWYgKHJpbmcuYmJveC5sbC55IDwgdGhpcy5iYm94LmxsLnkpIHRoaXMuYmJveC5sbC55ID0gcmluZy5iYm94LmxsLnk7XG4gICAgICBpZiAocmluZy5iYm94LnVyLnggPiB0aGlzLmJib3gudXIueCkgdGhpcy5iYm94LnVyLnggPSByaW5nLmJib3gudXIueDtcbiAgICAgIGlmIChyaW5nLmJib3gudXIueSA+IHRoaXMuYmJveC51ci55KSB0aGlzLmJib3gudXIueSA9IHJpbmcuYmJveC51ci55O1xuICAgICAgdGhpcy5pbnRlcmlvclJpbmdzLnB1c2gocmluZyk7XG4gICAgfVxuICAgIHRoaXMubXVsdGlQb2x5ID0gbXVsdGlQb2x5O1xuICB9XG4gIGdldFN3ZWVwRXZlbnRzKCkge1xuICAgIGNvbnN0IHN3ZWVwRXZlbnRzID0gdGhpcy5leHRlcmlvclJpbmcuZ2V0U3dlZXBFdmVudHMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHRoaXMuaW50ZXJpb3JSaW5ncy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHJpbmdTd2VlcEV2ZW50cyA9IHRoaXMuaW50ZXJpb3JSaW5nc1tpXS5nZXRTd2VlcEV2ZW50cygpO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpNYXggPSByaW5nU3dlZXBFdmVudHMubGVuZ3RoOyBqIDwgak1heDsgaisrKSB7XG4gICAgICAgIHN3ZWVwRXZlbnRzLnB1c2gocmluZ1N3ZWVwRXZlbnRzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN3ZWVwRXZlbnRzO1xuICB9XG59XG5jbGFzcyBNdWx0aVBvbHlJbiB7XG4gIGNvbnN0cnVjdG9yKGdlb20sIGlzU3ViamVjdCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShnZW9tKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZ2VvbWV0cnkgaXMgbm90IGEgdmFsaWQgUG9seWdvbiBvciBNdWx0aVBvbHlnb25cIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyBpZiB0aGUgaW5wdXQgbG9va3MgbGlrZSBhIHBvbHlnb24sIGNvbnZlcnQgaXQgdG8gYSBtdWx0aXBvbHlnb25cbiAgICAgIGlmICh0eXBlb2YgZ2VvbVswXVswXVswXSA9PT0gXCJudW1iZXJcIikgZ2VvbSA9IFtnZW9tXTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgLy8gVGhlIGlucHV0IGlzIGVpdGhlciBtYWxmb3JtZWQgb3IgaGFzIGVtcHR5IGFycmF5cy5cbiAgICAgIC8vIEluIGVpdGhlciBjYXNlLCBpdCB3aWxsIGJlIGhhbmRsZWQgbGF0ZXIgb24uXG4gICAgfVxuICAgIHRoaXMucG9seXMgPSBbXTtcbiAgICB0aGlzLmJib3ggPSB7XG4gICAgICBsbDoge1xuICAgICAgICB4OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIHk6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgfSxcbiAgICAgIHVyOiB7XG4gICAgICAgIHg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgeTogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IGdlb20ubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2x5ID0gbmV3IFBvbHlJbihnZW9tW2ldLCB0aGlzKTtcbiAgICAgIGlmIChwb2x5LmJib3gubGwueCA8IHRoaXMuYmJveC5sbC54KSB0aGlzLmJib3gubGwueCA9IHBvbHkuYmJveC5sbC54O1xuICAgICAgaWYgKHBvbHkuYmJveC5sbC55IDwgdGhpcy5iYm94LmxsLnkpIHRoaXMuYmJveC5sbC55ID0gcG9seS5iYm94LmxsLnk7XG4gICAgICBpZiAocG9seS5iYm94LnVyLnggPiB0aGlzLmJib3gudXIueCkgdGhpcy5iYm94LnVyLnggPSBwb2x5LmJib3gudXIueDtcbiAgICAgIGlmIChwb2x5LmJib3gudXIueSA+IHRoaXMuYmJveC51ci55KSB0aGlzLmJib3gudXIueSA9IHBvbHkuYmJveC51ci55O1xuICAgICAgdGhpcy5wb2x5cy5wdXNoKHBvbHkpO1xuICAgIH1cbiAgICB0aGlzLmlzU3ViamVjdCA9IGlzU3ViamVjdDtcbiAgfVxuICBnZXRTd2VlcEV2ZW50cygpIHtcbiAgICBjb25zdCBzd2VlcEV2ZW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gdGhpcy5wb2x5cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvbHlTd2VlcEV2ZW50cyA9IHRoaXMucG9seXNbaV0uZ2V0U3dlZXBFdmVudHMoKTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBqTWF4ID0gcG9seVN3ZWVwRXZlbnRzLmxlbmd0aDsgaiA8IGpNYXg7IGorKykge1xuICAgICAgICBzd2VlcEV2ZW50cy5wdXNoKHBvbHlTd2VlcEV2ZW50c1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzd2VlcEV2ZW50cztcbiAgfVxufVxuXG5jbGFzcyBSaW5nT3V0IHtcbiAgLyogR2l2ZW4gdGhlIHNlZ21lbnRzIGZyb20gdGhlIHN3ZWVwIGxpbmUgcGFzcywgY29tcHV0ZSAmIHJldHVybiBhIHNlcmllc1xuICAgKiBvZiBjbG9zZWQgcmluZ3MgZnJvbSBhbGwgdGhlIHNlZ21lbnRzIG1hcmtlZCB0byBiZSBwYXJ0IG9mIHRoZSByZXN1bHQgKi9cbiAgc3RhdGljIGZhY3RvcnkoYWxsU2VnbWVudHMpIHtcbiAgICBjb25zdCByaW5nc091dCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gYWxsU2VnbWVudHMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCBzZWdtZW50ID0gYWxsU2VnbWVudHNbaV07XG4gICAgICBpZiAoIXNlZ21lbnQuaXNJblJlc3VsdCgpIHx8IHNlZ21lbnQucmluZ091dCkgY29udGludWU7XG4gICAgICBsZXQgcHJldkV2ZW50ID0gbnVsbDtcbiAgICAgIGxldCBldmVudCA9IHNlZ21lbnQubGVmdFNFO1xuICAgICAgbGV0IG5leHRFdmVudCA9IHNlZ21lbnQucmlnaHRTRTtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IFtldmVudF07XG4gICAgICBjb25zdCBzdGFydGluZ1BvaW50ID0gZXZlbnQucG9pbnQ7XG4gICAgICBjb25zdCBpbnRlcnNlY3Rpb25MRXMgPSBbXTtcblxuICAgICAgLyogV2FsayB0aGUgY2hhaW4gb2YgbGlua2VkIGV2ZW50cyB0byBmb3JtIGEgY2xvc2VkIHJpbmcgKi9cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHByZXZFdmVudCA9IGV2ZW50O1xuICAgICAgICBldmVudCA9IG5leHRFdmVudDtcbiAgICAgICAgZXZlbnRzLnB1c2goZXZlbnQpO1xuXG4gICAgICAgIC8qIElzIHRoZSByaW5nIGNvbXBsZXRlPyAqL1xuICAgICAgICBpZiAoZXZlbnQucG9pbnQgPT09IHN0YXJ0aW5nUG9pbnQpIGJyZWFrO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZUxFcyA9IGV2ZW50LmdldEF2YWlsYWJsZUxpbmtlZEV2ZW50cygpO1xuXG4gICAgICAgICAgLyogRGlkIHdlIGhpdCBhIGRlYWQgZW5kPyBUaGlzIHNob3VsZG4ndCBoYXBwZW4uXG4gICAgICAgICAgICogSW5kaWNhdGVzIHNvbWUgZWFybGllciBwYXJ0IG9mIHRoZSBhbGdvcml0aG0gbWFsZnVuY3Rpb25lZC4gKi9cbiAgICAgICAgICBpZiAoYXZhaWxhYmxlTEVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RQdCA9IGV2ZW50c1swXS5wb2ludDtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RQdCA9IGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV0ucG9pbnQ7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjb21wbGV0ZSBvdXRwdXQgcmluZyBzdGFydGluZyBhdCBbJHtmaXJzdFB0Lnh9LGAgKyBgICR7Zmlyc3RQdC55fV0uIExhc3QgbWF0Y2hpbmcgc2VnbWVudCBmb3VuZCBlbmRzIGF0YCArIGAgWyR7bGFzdFB0Lnh9LCAke2xhc3RQdC55fV0uYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogT25seSBvbmUgd2F5IHRvIGdvLCBzbyBjb3RpbnVlIG9uIHRoZSBwYXRoICovXG4gICAgICAgICAgaWYgKGF2YWlsYWJsZUxFcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIG5leHRFdmVudCA9IGF2YWlsYWJsZUxFc1swXS5vdGhlclNFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogV2UgbXVzdCBoYXZlIGFuIGludGVyc2VjdGlvbi4gQ2hlY2sgZm9yIGEgY29tcGxldGVkIGxvb3AgKi9cbiAgICAgICAgICBsZXQgaW5kZXhMRSA9IG51bGw7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpNYXggPSBpbnRlcnNlY3Rpb25MRXMubGVuZ3RoOyBqIDwgak1heDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uTEVzW2pdLnBvaW50ID09PSBldmVudC5wb2ludCkge1xuICAgICAgICAgICAgICBpbmRleExFID0gajtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIEZvdW5kIGEgY29tcGxldGVkIGxvb3AuIEN1dCB0aGF0IG9mZiBhbmQgbWFrZSBhIHJpbmcgKi9cbiAgICAgICAgICBpZiAoaW5kZXhMRSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uTEUgPSBpbnRlcnNlY3Rpb25MRXMuc3BsaWNlKGluZGV4TEUpWzBdO1xuICAgICAgICAgICAgY29uc3QgcmluZ0V2ZW50cyA9IGV2ZW50cy5zcGxpY2UoaW50ZXJzZWN0aW9uTEUuaW5kZXgpO1xuICAgICAgICAgICAgcmluZ0V2ZW50cy51bnNoaWZ0KHJpbmdFdmVudHNbMF0ub3RoZXJTRSk7XG4gICAgICAgICAgICByaW5nc091dC5wdXNoKG5ldyBSaW5nT3V0KHJpbmdFdmVudHMucmV2ZXJzZSgpKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogcmVnaXN0ZXIgdGhlIGludGVyc2VjdGlvbiAqL1xuICAgICAgICAgIGludGVyc2VjdGlvbkxFcy5wdXNoKHtcbiAgICAgICAgICAgIGluZGV4OiBldmVudHMubGVuZ3RoLFxuICAgICAgICAgICAgcG9pbnQ6IGV2ZW50LnBvaW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLyogQ2hvb3NlIHRoZSBsZWZ0LW1vc3Qgb3B0aW9uIHRvIGNvbnRpbnVlIHRoZSB3YWxrICovXG4gICAgICAgICAgY29uc3QgY29tcGFyYXRvciA9IGV2ZW50LmdldExlZnRtb3N0Q29tcGFyYXRvcihwcmV2RXZlbnQpO1xuICAgICAgICAgIG5leHRFdmVudCA9IGF2YWlsYWJsZUxFcy5zb3J0KGNvbXBhcmF0b3IpWzBdLm90aGVyU0U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJpbmdzT3V0LnB1c2gobmV3IFJpbmdPdXQoZXZlbnRzKSk7XG4gICAgfVxuICAgIHJldHVybiByaW5nc091dDtcbiAgfVxuICBjb25zdHJ1Y3RvcihldmVudHMpIHtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IGV2ZW50cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGV2ZW50c1tpXS5zZWdtZW50LnJpbmdPdXQgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLnBvbHkgPSBudWxsO1xuICB9XG4gIGdldEdlb20oKSB7XG4gICAgLy8gUmVtb3ZlIHN1cGVyZmx1b3VzIHBvaW50cyAoaWUgZXh0cmEgcG9pbnRzIGFsb25nIGEgc3RyYWlnaHQgbGluZSksXG4gICAgbGV0IHByZXZQdCA9IHRoaXMuZXZlbnRzWzBdLnBvaW50O1xuICAgIGNvbnN0IHBvaW50cyA9IFtwcmV2UHRdO1xuICAgIGZvciAobGV0IGkgPSAxLCBpTWF4ID0gdGhpcy5ldmVudHMubGVuZ3RoIC0gMTsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgcHQgPSB0aGlzLmV2ZW50c1tpXS5wb2ludDtcbiAgICAgIGNvbnN0IG5leHRQdCA9IHRoaXMuZXZlbnRzW2kgKyAxXS5wb2ludDtcbiAgICAgIGlmIChjb21wYXJlVmVjdG9yQW5nbGVzKHB0LCBwcmV2UHQsIG5leHRQdCkgPT09IDApIGNvbnRpbnVlO1xuICAgICAgcG9pbnRzLnB1c2gocHQpO1xuICAgICAgcHJldlB0ID0gcHQ7XG4gICAgfVxuXG4gICAgLy8gcmluZyB3YXMgYWxsICh3aXRoaW4gcm91bmRpbmcgZXJyb3Igb2YgYW5nbGUgY2FsYykgY29saW5lYXIgcG9pbnRzXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDEpIHJldHVybiBudWxsO1xuXG4gICAgLy8gY2hlY2sgaWYgdGhlIHN0YXJ0aW5nIHBvaW50IGlzIG5lY2Vzc2FyeVxuICAgIGNvbnN0IHB0ID0gcG9pbnRzWzBdO1xuICAgIGNvbnN0IG5leHRQdCA9IHBvaW50c1sxXTtcbiAgICBpZiAoY29tcGFyZVZlY3RvckFuZ2xlcyhwdCwgcHJldlB0LCBuZXh0UHQpID09PSAwKSBwb2ludHMuc2hpZnQoKTtcbiAgICBwb2ludHMucHVzaChwb2ludHNbMF0pO1xuICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmlzRXh0ZXJpb3JSaW5nKCkgPyAxIDogLTE7XG4gICAgY29uc3QgaVN0YXJ0ID0gdGhpcy5pc0V4dGVyaW9yUmluZygpID8gMCA6IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGlFbmQgPSB0aGlzLmlzRXh0ZXJpb3JSaW5nKCkgPyBwb2ludHMubGVuZ3RoIDogLTE7XG4gICAgY29uc3Qgb3JkZXJlZFBvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBpU3RhcnQ7IGkgIT0gaUVuZDsgaSArPSBzdGVwKSBvcmRlcmVkUG9pbnRzLnB1c2goW3BvaW50c1tpXS54LCBwb2ludHNbaV0ueV0pO1xuICAgIHJldHVybiBvcmRlcmVkUG9pbnRzO1xuICB9XG4gIGlzRXh0ZXJpb3JSaW5nKCkge1xuICAgIGlmICh0aGlzLl9pc0V4dGVyaW9yUmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBlbmNsb3NpbmcgPSB0aGlzLmVuY2xvc2luZ1JpbmcoKTtcbiAgICAgIHRoaXMuX2lzRXh0ZXJpb3JSaW5nID0gZW5jbG9zaW5nID8gIWVuY2xvc2luZy5pc0V4dGVyaW9yUmluZygpIDogdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2lzRXh0ZXJpb3JSaW5nO1xuICB9XG4gIGVuY2xvc2luZ1JpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2VuY2xvc2luZ1JpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fZW5jbG9zaW5nUmluZyA9IHRoaXMuX2NhbGNFbmNsb3NpbmdSaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbmNsb3NpbmdSaW5nO1xuICB9XG5cbiAgLyogUmV0dXJucyB0aGUgcmluZyB0aGF0IGVuY2xvc2VzIHRoaXMgb25lLCBpZiBhbnkgKi9cbiAgX2NhbGNFbmNsb3NpbmdSaW5nKCkge1xuICAgIC8vIHN0YXJ0IHdpdGggdGhlIGVhbGllciBzd2VlcCBsaW5lIGV2ZW50IHNvIHRoYXQgdGhlIHByZXZTZWdcbiAgICAvLyBjaGFpbiBkb2Vzbid0IGxlYWQgdXMgaW5zaWRlIG9mIGEgbG9vcCBvZiBvdXJzXG4gICAgbGV0IGxlZnRNb3N0RXZ0ID0gdGhpcy5ldmVudHNbMF07XG4gICAgZm9yIChsZXQgaSA9IDEsIGlNYXggPSB0aGlzLmV2ZW50cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IGV2dCA9IHRoaXMuZXZlbnRzW2ldO1xuICAgICAgaWYgKFN3ZWVwRXZlbnQuY29tcGFyZShsZWZ0TW9zdEV2dCwgZXZ0KSA+IDApIGxlZnRNb3N0RXZ0ID0gZXZ0O1xuICAgIH1cbiAgICBsZXQgcHJldlNlZyA9IGxlZnRNb3N0RXZ0LnNlZ21lbnQucHJldkluUmVzdWx0KCk7XG4gICAgbGV0IHByZXZQcmV2U2VnID0gcHJldlNlZyA/IHByZXZTZWcucHJldkluUmVzdWx0KCkgOiBudWxsO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBubyBzZWdtZW50IGZvdW5kLCB0aHVzIG5vIHJpbmcgY2FuIGVuY2xvc2UgdXNcbiAgICAgIGlmICghcHJldlNlZykgcmV0dXJuIG51bGw7XG5cbiAgICAgIC8vIG5vIHNlZ21lbnRzIGJlbG93IHByZXYgc2VnbWVudCBmb3VuZCwgdGh1cyB0aGUgcmluZyBvZiB0aGUgcHJldlxuICAgICAgLy8gc2VnbWVudCBtdXN0IGxvb3AgYmFjayBhcm91bmQgYW5kIGVuY2xvc2UgdXNcbiAgICAgIGlmICghcHJldlByZXZTZWcpIHJldHVybiBwcmV2U2VnLnJpbmdPdXQ7XG5cbiAgICAgIC8vIGlmIHRoZSB0d28gc2VnbWVudHMgYXJlIG9mIGRpZmZlcmVudCByaW5ncywgdGhlIHJpbmcgb2YgdGhlIHByZXZcbiAgICAgIC8vIHNlZ21lbnQgbXVzdCBlaXRoZXIgbG9vcCBhcm91bmQgdXMgb3IgdGhlIHJpbmcgb2YgdGhlIHByZXYgcHJldlxuICAgICAgLy8gc2VnLCB3aGljaCB3b3VsZCBtYWtlIHVzIGFuZCB0aGUgcmluZyBvZiB0aGUgcHJldiBwZWVyc1xuICAgICAgaWYgKHByZXZQcmV2U2VnLnJpbmdPdXQgIT09IHByZXZTZWcucmluZ091dCkge1xuICAgICAgICBpZiAocHJldlByZXZTZWcucmluZ091dC5lbmNsb3NpbmdSaW5nKCkgIT09IHByZXZTZWcucmluZ091dCkge1xuICAgICAgICAgIHJldHVybiBwcmV2U2VnLnJpbmdPdXQ7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gcHJldlNlZy5yaW5nT3V0LmVuY2xvc2luZ1JpbmcoKTtcbiAgICAgIH1cblxuICAgICAgLy8gdHdvIHNlZ21lbnRzIGFyZSBmcm9tIHRoZSBzYW1lIHJpbmcsIHNvIHRoaXMgd2FzIGEgcGVuaXN1bGFcbiAgICAgIC8vIG9mIHRoYXQgcmluZy4gaXRlcmF0ZSBkb3dud2FyZCwga2VlcCBzZWFyY2hpbmdcbiAgICAgIHByZXZTZWcgPSBwcmV2UHJldlNlZy5wcmV2SW5SZXN1bHQoKTtcbiAgICAgIHByZXZQcmV2U2VnID0gcHJldlNlZyA/IHByZXZTZWcucHJldkluUmVzdWx0KCkgOiBudWxsO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUG9seU91dCB7XG4gIGNvbnN0cnVjdG9yKGV4dGVyaW9yUmluZykge1xuICAgIHRoaXMuZXh0ZXJpb3JSaW5nID0gZXh0ZXJpb3JSaW5nO1xuICAgIGV4dGVyaW9yUmluZy5wb2x5ID0gdGhpcztcbiAgICB0aGlzLmludGVyaW9yUmluZ3MgPSBbXTtcbiAgfVxuICBhZGRJbnRlcmlvcihyaW5nKSB7XG4gICAgdGhpcy5pbnRlcmlvclJpbmdzLnB1c2gocmluZyk7XG4gICAgcmluZy5wb2x5ID0gdGhpcztcbiAgfVxuICBnZXRHZW9tKCkge1xuICAgIGNvbnN0IGdlb20gPSBbdGhpcy5leHRlcmlvclJpbmcuZ2V0R2VvbSgpXTtcbiAgICAvLyBleHRlcmlvciByaW5nIHdhcyBhbGwgKHdpdGhpbiByb3VuZGluZyBlcnJvciBvZiBhbmdsZSBjYWxjKSBjb2xpbmVhciBwb2ludHNcbiAgICBpZiAoZ2VvbVswXSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSB0aGlzLmludGVyaW9yUmluZ3MubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCByaW5nR2VvbSA9IHRoaXMuaW50ZXJpb3JSaW5nc1tpXS5nZXRHZW9tKCk7XG4gICAgICAvLyBpbnRlcmlvciByaW5nIHdhcyBhbGwgKHdpdGhpbiByb3VuZGluZyBlcnJvciBvZiBhbmdsZSBjYWxjKSBjb2xpbmVhciBwb2ludHNcbiAgICAgIGlmIChyaW5nR2VvbSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBnZW9tLnB1c2gocmluZ0dlb20pO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbTtcbiAgfVxufVxuY2xhc3MgTXVsdGlQb2x5T3V0IHtcbiAgY29uc3RydWN0b3IocmluZ3MpIHtcbiAgICB0aGlzLnJpbmdzID0gcmluZ3M7XG4gICAgdGhpcy5wb2x5cyA9IHRoaXMuX2NvbXBvc2VQb2x5cyhyaW5ncyk7XG4gIH1cbiAgZ2V0R2VvbSgpIHtcbiAgICBjb25zdCBnZW9tID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSB0aGlzLnBvbHlzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgcG9seUdlb20gPSB0aGlzLnBvbHlzW2ldLmdldEdlb20oKTtcbiAgICAgIC8vIGV4dGVyaW9yIHJpbmcgd2FzIGFsbCAod2l0aGluIHJvdW5kaW5nIGVycm9yIG9mIGFuZ2xlIGNhbGMpIGNvbGluZWFyIHBvaW50c1xuICAgICAgaWYgKHBvbHlHZW9tID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIGdlb20ucHVzaChwb2x5R2VvbSk7XG4gICAgfVxuICAgIHJldHVybiBnZW9tO1xuICB9XG4gIF9jb21wb3NlUG9seXMocmluZ3MpIHtcbiAgICBjb25zdCBwb2x5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gcmluZ3MubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCByaW5nID0gcmluZ3NbaV07XG4gICAgICBpZiAocmluZy5wb2x5KSBjb250aW51ZTtcbiAgICAgIGlmIChyaW5nLmlzRXh0ZXJpb3JSaW5nKCkpIHBvbHlzLnB1c2gobmV3IFBvbHlPdXQocmluZykpO2Vsc2Uge1xuICAgICAgICBjb25zdCBlbmNsb3NpbmdSaW5nID0gcmluZy5lbmNsb3NpbmdSaW5nKCk7XG4gICAgICAgIGlmICghZW5jbG9zaW5nUmluZy5wb2x5KSBwb2x5cy5wdXNoKG5ldyBQb2x5T3V0KGVuY2xvc2luZ1JpbmcpKTtcbiAgICAgICAgZW5jbG9zaW5nUmluZy5wb2x5LmFkZEludGVyaW9yKHJpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9seXM7XG4gIH1cbn1cblxuLyoqXG4gKiBOT1RFOiAgV2UgbXVzdCBiZSBjYXJlZnVsIG5vdCB0byBjaGFuZ2UgYW55IHNlZ21lbnRzIHdoaWxlXG4gKiAgICAgICAgdGhleSBhcmUgaW4gdGhlIFNwbGF5VHJlZS4gQUZBSUssIHRoZXJlJ3Mgbm8gd2F5IHRvIHRlbGxcbiAqICAgICAgICB0aGUgdHJlZSB0byByZWJhbGFuY2UgaXRzZWxmIC0gdGh1cyBiZWZvcmUgc3BsaXR0aW5nXG4gKiAgICAgICAgYSBzZWdtZW50IHRoYXQncyBpbiB0aGUgdHJlZSwgd2UgcmVtb3ZlIGl0IGZyb20gdGhlIHRyZWUsXG4gKiAgICAgICAgZG8gdGhlIHNwbGl0LCB0aGVuIHJlLWluc2VydCBpdC4gKEV2ZW4gdGhvdWdoIHNwbGl0dGluZyBhXG4gKiAgICAgICAgc2VnbWVudCAqc2hvdWxkbid0KiBjaGFuZ2UgaXRzIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlXG4gKiAgICAgICAgc3dlZXAgbGluZSB0cmVlLCB0aGUgcmVhbGl0eSBpcyBiZWNhdXNlIG9mIHJvdW5kaW5nIGVycm9ycyxcbiAqICAgICAgICBpdCBzb21ldGltZXMgZG9lcy4pXG4gKi9cblxuY2xhc3MgU3dlZXBMaW5lIHtcbiAgY29uc3RydWN0b3IocXVldWUpIHtcbiAgICBsZXQgY29tcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogU2VnbWVudC5jb21wYXJlO1xuICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICB0aGlzLnRyZWUgPSBuZXcgU3BsYXlUcmVlKGNvbXBhcmF0b3IpO1xuICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgfVxuICBwcm9jZXNzKGV2ZW50KSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IGV2ZW50LnNlZ21lbnQ7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gW107XG5cbiAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IGJlZW4gY29uc3VtZWQgYnkgYW5vdGhlciBzZWdtZW50LFxuICAgIC8vIGNsZWFuIHVwIG91ciBib2R5IHBhcnRzIGFuZCBnZXQgb3V0XG4gICAgaWYgKGV2ZW50LmNvbnN1bWVkQnkpIHtcbiAgICAgIGlmIChldmVudC5pc0xlZnQpIHRoaXMucXVldWUucmVtb3ZlKGV2ZW50Lm90aGVyU0UpO2Vsc2UgdGhpcy50cmVlLnJlbW92ZShzZWdtZW50KTtcbiAgICAgIHJldHVybiBuZXdFdmVudHM7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBldmVudC5pc0xlZnQgPyB0aGlzLnRyZWUuYWRkKHNlZ21lbnQpIDogdGhpcy50cmVlLmZpbmQoc2VnbWVudCk7XG4gICAgaWYgKCFub2RlKSB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIHNlZ21lbnQgIyR7c2VnbWVudC5pZH0gYCArIGBbJHtzZWdtZW50LmxlZnRTRS5wb2ludC54fSwgJHtzZWdtZW50LmxlZnRTRS5wb2ludC55fV0gLT4gYCArIGBbJHtzZWdtZW50LnJpZ2h0U0UucG9pbnQueH0sICR7c2VnbWVudC5yaWdodFNFLnBvaW50Lnl9XSBgICsgXCJpbiBTd2VlcExpbmUgdHJlZS5cIik7XG4gICAgbGV0IHByZXZOb2RlID0gbm9kZTtcbiAgICBsZXQgbmV4dE5vZGUgPSBub2RlO1xuICAgIGxldCBwcmV2U2VnID0gdW5kZWZpbmVkO1xuICAgIGxldCBuZXh0U2VnID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gc2tpcCBjb25zdW1lZCBzZWdtZW50cyBzdGlsbCBpbiB0cmVlXG4gICAgd2hpbGUgKHByZXZTZWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJldk5vZGUgPSB0aGlzLnRyZWUucHJldihwcmV2Tm9kZSk7XG4gICAgICBpZiAocHJldk5vZGUgPT09IG51bGwpIHByZXZTZWcgPSBudWxsO2Vsc2UgaWYgKHByZXZOb2RlLmtleS5jb25zdW1lZEJ5ID09PSB1bmRlZmluZWQpIHByZXZTZWcgPSBwcmV2Tm9kZS5rZXk7XG4gICAgfVxuXG4gICAgLy8gc2tpcCBjb25zdW1lZCBzZWdtZW50cyBzdGlsbCBpbiB0cmVlXG4gICAgd2hpbGUgKG5leHRTZWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV4dE5vZGUgPSB0aGlzLnRyZWUubmV4dChuZXh0Tm9kZSk7XG4gICAgICBpZiAobmV4dE5vZGUgPT09IG51bGwpIG5leHRTZWcgPSBudWxsO2Vsc2UgaWYgKG5leHROb2RlLmtleS5jb25zdW1lZEJ5ID09PSB1bmRlZmluZWQpIG5leHRTZWcgPSBuZXh0Tm9kZS5rZXk7XG4gICAgfVxuICAgIGlmIChldmVudC5pc0xlZnQpIHtcbiAgICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb25zIGFnYWluc3QgdGhlIHByZXZpb3VzIHNlZ21lbnQgaW4gdGhlIHN3ZWVwIGxpbmVcbiAgICAgIGxldCBwcmV2TXlTcGxpdHRlciA9IG51bGw7XG4gICAgICBpZiAocHJldlNlZykge1xuICAgICAgICBjb25zdCBwcmV2SW50ZXIgPSBwcmV2U2VnLmdldEludGVyc2VjdGlvbihzZWdtZW50KTtcbiAgICAgICAgaWYgKHByZXZJbnRlciAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghc2VnbWVudC5pc0FuRW5kcG9pbnQocHJldkludGVyKSkgcHJldk15U3BsaXR0ZXIgPSBwcmV2SW50ZXI7XG4gICAgICAgICAgaWYgKCFwcmV2U2VnLmlzQW5FbmRwb2ludChwcmV2SW50ZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudHNGcm9tU3BsaXQgPSB0aGlzLl9zcGxpdFNhZmVseShwcmV2U2VnLCBwcmV2SW50ZXIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBuZXdFdmVudHNGcm9tU3BsaXQubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgICAgICAgIG5ld0V2ZW50cy5wdXNoKG5ld0V2ZW50c0Zyb21TcGxpdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb25zIGFnYWluc3QgdGhlIG5leHQgc2VnbWVudCBpbiB0aGUgc3dlZXAgbGluZVxuICAgICAgbGV0IG5leHRNeVNwbGl0dGVyID0gbnVsbDtcbiAgICAgIGlmIChuZXh0U2VnKSB7XG4gICAgICAgIGNvbnN0IG5leHRJbnRlciA9IG5leHRTZWcuZ2V0SW50ZXJzZWN0aW9uKHNlZ21lbnQpO1xuICAgICAgICBpZiAobmV4dEludGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFzZWdtZW50LmlzQW5FbmRwb2ludChuZXh0SW50ZXIpKSBuZXh0TXlTcGxpdHRlciA9IG5leHRJbnRlcjtcbiAgICAgICAgICBpZiAoIW5leHRTZWcuaXNBbkVuZHBvaW50KG5leHRJbnRlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50c0Zyb21TcGxpdCA9IHRoaXMuX3NwbGl0U2FmZWx5KG5leHRTZWcsIG5leHRJbnRlcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IG5ld0V2ZW50c0Zyb21TcGxpdC5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgbmV3RXZlbnRzLnB1c2gobmV3RXZlbnRzRnJvbVNwbGl0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIGV2ZW4gaWYgd2UgZmluZCBtb3JlIHRoYW4gb25lIGludGVyc2VjdGlvbiB3ZSBvbmx5XG4gICAgICAvLyBzcGlsdCBvbiB0aGUgJ2VhcmxpZXN0JyAoc3dlZXAtbGluZSBzdHlsZSkgb2YgdGhlIGludGVyc2VjdGlvbnMuXG4gICAgICAvLyBUaGUgb3RoZXIgaW50ZXJzZWN0aW9uIHdpbGwgYmUgaGFuZGxlZCBpbiBhIGZ1dHVyZSBwcm9jZXNzKCkuXG4gICAgICBpZiAocHJldk15U3BsaXR0ZXIgIT09IG51bGwgfHwgbmV4dE15U3BsaXR0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IG15U3BsaXR0ZXIgPSBudWxsO1xuICAgICAgICBpZiAocHJldk15U3BsaXR0ZXIgPT09IG51bGwpIG15U3BsaXR0ZXIgPSBuZXh0TXlTcGxpdHRlcjtlbHNlIGlmIChuZXh0TXlTcGxpdHRlciA9PT0gbnVsbCkgbXlTcGxpdHRlciA9IHByZXZNeVNwbGl0dGVyO2Vsc2Uge1xuICAgICAgICAgIGNvbnN0IGNtcFNwbGl0dGVycyA9IFN3ZWVwRXZlbnQuY29tcGFyZVBvaW50cyhwcmV2TXlTcGxpdHRlciwgbmV4dE15U3BsaXR0ZXIpO1xuICAgICAgICAgIG15U3BsaXR0ZXIgPSBjbXBTcGxpdHRlcnMgPD0gMCA/IHByZXZNeVNwbGl0dGVyIDogbmV4dE15U3BsaXR0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSb3VuZGluZyBlcnJvcnMgY2FuIGNhdXNlIGNoYW5nZXMgaW4gb3JkZXJpbmcsXG4gICAgICAgIC8vIHNvIHJlbW92ZSBhZmVjdGVkIHNlZ21lbnRzIGFuZCByaWdodCBzd2VlcCBldmVudHMgYmVmb3JlIHNwbGl0dGluZ1xuICAgICAgICB0aGlzLnF1ZXVlLnJlbW92ZShzZWdtZW50LnJpZ2h0U0UpO1xuICAgICAgICBuZXdFdmVudHMucHVzaChzZWdtZW50LnJpZ2h0U0UpO1xuICAgICAgICBjb25zdCBuZXdFdmVudHNGcm9tU3BsaXQgPSBzZWdtZW50LnNwbGl0KG15U3BsaXR0ZXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IG5ld0V2ZW50c0Zyb21TcGxpdC5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgICBuZXdFdmVudHMucHVzaChuZXdFdmVudHNGcm9tU3BsaXRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV3RXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gV2UgZm91bmQgc29tZSBpbnRlcnNlY3Rpb25zLCBzbyByZS1kbyB0aGUgY3VycmVudCBldmVudCB0b1xuICAgICAgICAvLyBtYWtlIHN1cmUgc3dlZXAgbGluZSBvcmRlcmluZyBpcyB0b3RhbGx5IGNvbnNpc3RlbnQgZm9yIGxhdGVyXG4gICAgICAgIC8vIHVzZSB3aXRoIHRoZSBzZWdtZW50ICdwcmV2JyBwb2ludGVyc1xuICAgICAgICB0aGlzLnRyZWUucmVtb3ZlKHNlZ21lbnQpO1xuICAgICAgICBuZXdFdmVudHMucHVzaChldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb25lIHdpdGggbGVmdCBldmVudFxuICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgIHNlZ21lbnQucHJldiA9IHByZXZTZWc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV2ZW50LmlzUmlnaHRcblxuICAgICAgLy8gc2luY2Ugd2UncmUgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBzd2VlcCBsaW5lLCBjaGVjayBmb3JcbiAgICAgIC8vIGludGVyc2VjdGlvbnMgYmV0d2VlbiBvdXIgcHJldmlvdXMgYW5kIG5leHQgc2VnbWVudHNcbiAgICAgIGlmIChwcmV2U2VnICYmIG5leHRTZWcpIHtcbiAgICAgICAgY29uc3QgaW50ZXIgPSBwcmV2U2VnLmdldEludGVyc2VjdGlvbihuZXh0U2VnKTtcbiAgICAgICAgaWYgKGludGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCFwcmV2U2VnLmlzQW5FbmRwb2ludChpbnRlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50c0Zyb21TcGxpdCA9IHRoaXMuX3NwbGl0U2FmZWx5KHByZXZTZWcsIGludGVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gbmV3RXZlbnRzRnJvbVNwbGl0Lmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICAgICAgICBuZXdFdmVudHMucHVzaChuZXdFdmVudHNGcm9tU3BsaXRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW5leHRTZWcuaXNBbkVuZHBvaW50KGludGVyKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3RXZlbnRzRnJvbVNwbGl0ID0gdGhpcy5fc3BsaXRTYWZlbHkobmV4dFNlZywgaW50ZXIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBuZXdFdmVudHNGcm9tU3BsaXQubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgICAgICAgIG5ld0V2ZW50cy5wdXNoKG5ld0V2ZW50c0Zyb21TcGxpdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRyZWUucmVtb3ZlKHNlZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RXZlbnRzO1xuICB9XG5cbiAgLyogU2FmZWx5IHNwbGl0IGEgc2VnbWVudCB0aGF0IGlzIGN1cnJlbnRseSBpbiB0aGUgZGF0YXN0cnVjdHVyZXNcbiAgICogSUUgLSBhIHNlZ21lbnQgb3RoZXIgdGhhbiB0aGUgb25lIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gKi9cbiAgX3NwbGl0U2FmZWx5KHNlZywgcHQpIHtcbiAgICAvLyBSb3VuZGluZyBlcnJvcnMgY2FuIGNhdXNlIGNoYW5nZXMgaW4gb3JkZXJpbmcsXG4gICAgLy8gc28gcmVtb3ZlIGFmZWN0ZWQgc2VnbWVudHMgYW5kIHJpZ2h0IHN3ZWVwIGV2ZW50cyBiZWZvcmUgc3BsaXR0aW5nXG4gICAgLy8gcmVtb3ZlTm9kZSgpIGRvZXNuJ3Qgd29yaywgc28gaGF2ZSByZS1maW5kIHRoZSBzZWdcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdzhyL3NwbGF5LXRyZWUvcHVsbC81XG4gICAgdGhpcy50cmVlLnJlbW92ZShzZWcpO1xuICAgIGNvbnN0IHJpZ2h0U0UgPSBzZWcucmlnaHRTRTtcbiAgICB0aGlzLnF1ZXVlLnJlbW92ZShyaWdodFNFKTtcbiAgICBjb25zdCBuZXdFdmVudHMgPSBzZWcuc3BsaXQocHQpO1xuICAgIG5ld0V2ZW50cy5wdXNoKHJpZ2h0U0UpO1xuICAgIC8vIHNwbGl0dGluZyBjYW4gdHJpZ2dlciBjb25zdW1wdGlvblxuICAgIGlmIChzZWcuY29uc3VtZWRCeSA9PT0gdW5kZWZpbmVkKSB0aGlzLnRyZWUuYWRkKHNlZyk7XG4gICAgcmV0dXJuIG5ld0V2ZW50cztcbiAgfVxufVxuXG4vLyBMaW1pdHMgb24gaXRlcmF0aXZlIHByb2Nlc3NlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzIC0gdXN1YWxseSBjYXVzZWQgYnkgZmxvYXRpbmctcG9pbnQgbWF0aCByb3VuZC1vZmYgZXJyb3JzLlxuY29uc3QgUE9MWUdPTl9DTElQUElOR19NQVhfUVVFVUVfU0laRSA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52LlBPTFlHT05fQ0xJUFBJTkdfTUFYX1FVRVVFX1NJWkUgfHwgMTAwMDAwMDtcbmNvbnN0IFBPTFlHT05fQ0xJUFBJTkdfTUFYX1NXRUVQTElORV9TRUdNRU5UUyA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52LlBPTFlHT05fQ0xJUFBJTkdfTUFYX1NXRUVQTElORV9TRUdNRU5UUyB8fCAxMDAwMDAwO1xuY2xhc3MgT3BlcmF0aW9uIHtcbiAgcnVuKHR5cGUsIGdlb20sIG1vcmVHZW9tcykge1xuICAgIG9wZXJhdGlvbi50eXBlID0gdHlwZTtcbiAgICByb3VuZGVyLnJlc2V0KCk7XG5cbiAgICAvKiBDb252ZXJ0IGlucHV0cyB0byBNdWx0aVBvbHkgb2JqZWN0cyAqL1xuICAgIGNvbnN0IG11bHRpcG9seXMgPSBbbmV3IE11bHRpUG9seUluKGdlb20sIHRydWUpXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IG1vcmVHZW9tcy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIG11bHRpcG9seXMucHVzaChuZXcgTXVsdGlQb2x5SW4obW9yZUdlb21zW2ldLCBmYWxzZSkpO1xuICAgIH1cbiAgICBvcGVyYXRpb24ubnVtTXVsdGlQb2x5cyA9IG11bHRpcG9seXMubGVuZ3RoO1xuXG4gICAgLyogQkJveCBvcHRpbWl6YXRpb24gZm9yIGRpZmZlcmVuY2Ugb3BlcmF0aW9uXG4gICAgICogSWYgdGhlIGJib3ggb2YgYSBtdWx0aXBvbHlnb24gdGhhdCdzIHBhcnQgb2YgdGhlIGNsaXBwaW5nIGRvZXNuJ3RcbiAgICAgKiBpbnRlcnNlY3QgdGhlIGJib3ggb2YgdGhlIHN1YmplY3QgYXQgYWxsLCB3ZSBjYW4ganVzdCBkcm9wIHRoYXRcbiAgICAgKiBtdWx0aXBsb3lnb24uICovXG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBcImRpZmZlcmVuY2VcIikge1xuICAgICAgLy8gaW4gcGxhY2UgcmVtb3ZhbFxuICAgICAgY29uc3Qgc3ViamVjdCA9IG11bHRpcG9seXNbMF07XG4gICAgICBsZXQgaSA9IDE7XG4gICAgICB3aGlsZSAoaSA8IG11bHRpcG9seXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChnZXRCYm94T3ZlcmxhcChtdWx0aXBvbHlzW2ldLmJib3gsIHN1YmplY3QuYmJveCkgIT09IG51bGwpIGkrKztlbHNlIG11bHRpcG9seXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEJCb3ggb3B0aW1pemF0aW9uIGZvciBpbnRlcnNlY3Rpb24gb3BlcmF0aW9uXG4gICAgICogSWYgd2UgY2FuIGZpbmQgYW55IHBhaXIgb2YgbXVsdGlwb2x5Z29ucyB3aG9zZSBiYm94IGRvZXMgbm90IG92ZXJsYXAsXG4gICAgICogdGhlbiB0aGUgcmVzdWx0IHdpbGwgYmUgZW1wdHkuICovXG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBcImludGVyc2VjdGlvblwiKSB7XG4gICAgICAvLyBUT0RPOiB0aGlzIGlzIE8obl4yKSBpbiBudW1iZXIgb2YgcG9seWdvbnMuIEJ5IHNvcnRpbmcgdGhlIGJib3hlcyxcbiAgICAgIC8vICAgICAgIGl0IGNvdWxkIGJlIG9wdGltaXplZCB0byBPKG4gKiBsbihuKSlcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gbXVsdGlwb2x5cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgY29uc3QgbXBBID0gbXVsdGlwb2x5c1tpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxLCBqTWF4ID0gbXVsdGlwb2x5cy5sZW5ndGg7IGogPCBqTWF4OyBqKyspIHtcbiAgICAgICAgICBpZiAoZ2V0QmJveE92ZXJsYXAobXBBLmJib3gsIG11bHRpcG9seXNbal0uYmJveCkgPT09IG51bGwpIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIFB1dCBzZWdtZW50IGVuZHBvaW50cyBpbiBhIHByaW9yaXR5IHF1ZXVlICovXG4gICAgY29uc3QgcXVldWUgPSBuZXcgU3BsYXlUcmVlKFN3ZWVwRXZlbnQuY29tcGFyZSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBtdWx0aXBvbHlzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3Qgc3dlZXBFdmVudHMgPSBtdWx0aXBvbHlzW2ldLmdldFN3ZWVwRXZlbnRzKCk7XG4gICAgICBmb3IgKGxldCBqID0gMCwgak1heCA9IHN3ZWVwRXZlbnRzLmxlbmd0aDsgaiA8IGpNYXg7IGorKykge1xuICAgICAgICBxdWV1ZS5pbnNlcnQoc3dlZXBFdmVudHNbal0pO1xuICAgICAgICBpZiAocXVldWUuc2l6ZSA+IFBPTFlHT05fQ0xJUFBJTkdfTUFYX1FVRVVFX1NJWkUpIHtcbiAgICAgICAgICAvLyBwcmV2ZW50cyBhbiBpbmZpbml0ZSBsb29wLCBhbiBvdGhlcndpc2UgY29tbW9uIG1hbmlmZXN0YXRpb24gb2YgYnVnc1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluZmluaXRlIGxvb3Agd2hlbiBwdXR0aW5nIHNlZ21lbnQgZW5kcG9pbnRzIGluIGEgcHJpb3JpdHkgcXVldWUgXCIgKyBcIihxdWV1ZSBzaXplIHRvbyBiaWcpLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIFBhc3MgdGhlIHN3ZWVwIGxpbmUgb3ZlciB0aG9zZSBlbmRwb2ludHMgKi9cbiAgICBjb25zdCBzd2VlcExpbmUgPSBuZXcgU3dlZXBMaW5lKHF1ZXVlKTtcbiAgICBsZXQgcHJldlF1ZXVlU2l6ZSA9IHF1ZXVlLnNpemU7XG4gICAgbGV0IG5vZGUgPSBxdWV1ZS5wb3AoKTtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgY29uc3QgZXZ0ID0gbm9kZS5rZXk7XG4gICAgICBpZiAocXVldWUuc2l6ZSA9PT0gcHJldlF1ZXVlU2l6ZSkge1xuICAgICAgICAvLyBwcmV2ZW50cyBhbiBpbmZpbml0ZSBsb29wLCBhbiBvdGhlcndpc2UgY29tbW9uIG1hbmlmZXN0YXRpb24gb2YgYnVnc1xuICAgICAgICBjb25zdCBzZWcgPSBldnQuc2VnbWVudDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcG9wKCkgJHtldnQuaXNMZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCJ9IFN3ZWVwRXZlbnQgYCArIGBbJHtldnQucG9pbnQueH0sICR7ZXZ0LnBvaW50Lnl9XSBmcm9tIHNlZ21lbnQgIyR7c2VnLmlkfSBgICsgYFske3NlZy5sZWZ0U0UucG9pbnQueH0sICR7c2VnLmxlZnRTRS5wb2ludC55fV0gLT4gYCArIGBbJHtzZWcucmlnaHRTRS5wb2ludC54fSwgJHtzZWcucmlnaHRTRS5wb2ludC55fV0gZnJvbSBxdWV1ZS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChxdWV1ZS5zaXplID4gUE9MWUdPTl9DTElQUElOR19NQVhfUVVFVUVfU0laRSkge1xuICAgICAgICAvLyBwcmV2ZW50cyBhbiBpbmZpbml0ZSBsb29wLCBhbiBvdGhlcndpc2UgY29tbW9uIG1hbmlmZXN0YXRpb24gb2YgYnVnc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmZpbml0ZSBsb29wIHdoZW4gcGFzc2luZyBzd2VlcCBsaW5lIG92ZXIgZW5kcG9pbnRzIFwiICsgXCIocXVldWUgc2l6ZSB0b28gYmlnKS5cIik7XG4gICAgICB9XG4gICAgICBpZiAoc3dlZXBMaW5lLnNlZ21lbnRzLmxlbmd0aCA+IFBPTFlHT05fQ0xJUFBJTkdfTUFYX1NXRUVQTElORV9TRUdNRU5UUykge1xuICAgICAgICAvLyBwcmV2ZW50cyBhbiBpbmZpbml0ZSBsb29wLCBhbiBvdGhlcndpc2UgY29tbW9uIG1hbmlmZXN0YXRpb24gb2YgYnVnc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmZpbml0ZSBsb29wIHdoZW4gcGFzc2luZyBzd2VlcCBsaW5lIG92ZXIgZW5kcG9pbnRzIFwiICsgXCIodG9vIG1hbnkgc3dlZXAgbGluZSBzZWdtZW50cykuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3RXZlbnRzID0gc3dlZXBMaW5lLnByb2Nlc3MoZXZ0KTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gbmV3RXZlbnRzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICBjb25zdCBldnQgPSBuZXdFdmVudHNbaV07XG4gICAgICAgIGlmIChldnQuY29uc3VtZWRCeSA9PT0gdW5kZWZpbmVkKSBxdWV1ZS5pbnNlcnQoZXZ0KTtcbiAgICAgIH1cbiAgICAgIHByZXZRdWV1ZVNpemUgPSBxdWV1ZS5zaXplO1xuICAgICAgbm9kZSA9IHF1ZXVlLnBvcCgpO1xuICAgIH1cblxuICAgIC8vIGZyZWUgc29tZSBtZW1vcnkgd2UgZG9uJ3QgbmVlZCBhbnltb3JlXG4gICAgcm91bmRlci5yZXNldCgpO1xuXG4gICAgLyogQ29sbGVjdCBhbmQgY29tcGlsZSBzZWdtZW50cyB3ZSdyZSBrZWVwaW5nIGludG8gYSBtdWx0aXBvbHlnb24gKi9cbiAgICBjb25zdCByaW5nc091dCA9IFJpbmdPdXQuZmFjdG9yeShzd2VlcExpbmUuc2VnbWVudHMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNdWx0aVBvbHlPdXQocmluZ3NPdXQpO1xuICAgIHJldHVybiByZXN1bHQuZ2V0R2VvbSgpO1xuICB9XG59XG5cbi8vIHNpbmdsZXRvbiBhdmFpbGFibGUgYnkgaW1wb3J0XG5jb25zdCBvcGVyYXRpb24gPSBuZXcgT3BlcmF0aW9uKCk7XG5cbmNvbnN0IHVuaW9uID0gZnVuY3Rpb24gKGdlb20pIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1vcmVHZW9tcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbW9yZUdlb21zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gb3BlcmF0aW9uLnJ1bihcInVuaW9uXCIsIGdlb20sIG1vcmVHZW9tcyk7XG59O1xuY29uc3QgaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKGdlb20pIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBtb3JlR2VvbXMgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIG1vcmVHZW9tc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuICByZXR1cm4gb3BlcmF0aW9uLnJ1bihcImludGVyc2VjdGlvblwiLCBnZW9tLCBtb3JlR2VvbXMpO1xufTtcbmNvbnN0IHhvciA9IGZ1bmN0aW9uIChnZW9tKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgbW9yZUdlb21zID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBtb3JlR2VvbXNbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cbiAgcmV0dXJuIG9wZXJhdGlvbi5ydW4oXCJ4b3JcIiwgZ2VvbSwgbW9yZUdlb21zKTtcbn07XG5jb25zdCBkaWZmZXJlbmNlID0gZnVuY3Rpb24gKHN1YmplY3RHZW9tKSB7XG4gIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgY2xpcHBpbmdHZW9tcyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgY2xpcHBpbmdHZW9tc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgfVxuICByZXR1cm4gb3BlcmF0aW9uLnJ1bihcImRpZmZlcmVuY2VcIiwgc3ViamVjdEdlb20sIGNsaXBwaW5nR2VvbXMpO1xufTtcbnZhciBpbmRleCA9IHtcbiAgdW5pb246IHVuaW9uLFxuICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvbixcbiAgeG9yOiB4b3IsXG4gIGRpZmZlcmVuY2U6IGRpZmZlcmVuY2Vcbn07XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/polygon-clipping/dist/polygon-clipping.esm.js\n");

/***/ })

};
;