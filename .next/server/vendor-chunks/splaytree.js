"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/splaytree";
exports.ids = ["vendor-chunks/splaytree"];
exports.modules = {

/***/ "(ssr)/./node_modules/splaytree/dist/splay.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/splaytree/dist/splay.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * splaytree v3.1.2\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar Node = /** @class */ (function () {\r\n    function Node(key, data) {\r\n        this.next = null;\r\n        this.key = key;\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n    return Node;\r\n}());\n\n/* follows \"An implementation of top-down splaying\"\r\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n */\r\nfunction DEFAULT_COMPARE(a, b) {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n/**\r\n * Simple top down splay, not requiring i to be in the tree t.\r\n */\r\nfunction splay(i, t, comparator) {\r\n    var N = new Node(null, null);\r\n    var l = N;\r\n    var r = N;\r\n    while (true) {\r\n        var cmp = comparator(i, t.key);\r\n        //if (i < t.key) {\r\n        if (cmp < 0) {\r\n            if (t.left === null)\r\n                break;\r\n            //if (i < t.left.key) {\r\n            if (comparator(i, t.left.key) < 0) {\r\n                var y = t.left; /* rotate right */\r\n                t.left = y.right;\r\n                y.right = t;\r\n                t = y;\r\n                if (t.left === null)\r\n                    break;\r\n            }\r\n            r.left = t; /* link right */\r\n            r = t;\r\n            t = t.left;\r\n            //} else if (i > t.key) {\r\n        }\r\n        else if (cmp > 0) {\r\n            if (t.right === null)\r\n                break;\r\n            //if (i > t.right.key) {\r\n            if (comparator(i, t.right.key) > 0) {\r\n                var y = t.right; /* rotate left */\r\n                t.right = y.left;\r\n                y.left = t;\r\n                t = y;\r\n                if (t.right === null)\r\n                    break;\r\n            }\r\n            l.right = t; /* link left */\r\n            l = t;\r\n            t = t.right;\r\n        }\r\n        else\r\n            break;\r\n    }\r\n    /* assemble */\r\n    l.right = t.left;\r\n    r.left = t.right;\r\n    t.left = N.right;\r\n    t.right = N.left;\r\n    return t;\r\n}\r\nfunction insert(i, data, t, comparator) {\r\n    var node = new Node(i, data);\r\n    if (t === null) {\r\n        node.left = node.right = null;\r\n        return node;\r\n    }\r\n    t = splay(i, t, comparator);\r\n    var cmp = comparator(i, t.key);\r\n    if (cmp < 0) {\r\n        node.left = t.left;\r\n        node.right = t;\r\n        t.left = null;\r\n    }\r\n    else if (cmp >= 0) {\r\n        node.right = t.right;\r\n        node.left = t;\r\n        t.right = null;\r\n    }\r\n    return node;\r\n}\r\nfunction split(key, v, comparator) {\r\n    var left = null;\r\n    var right = null;\r\n    if (v) {\r\n        v = splay(key, v, comparator);\r\n        var cmp = comparator(v.key, key);\r\n        if (cmp === 0) {\r\n            left = v.left;\r\n            right = v.right;\r\n        }\r\n        else if (cmp < 0) {\r\n            right = v.right;\r\n            v.right = null;\r\n            left = v;\r\n        }\r\n        else {\r\n            left = v.left;\r\n            v.left = null;\r\n            right = v;\r\n        }\r\n    }\r\n    return { left: left, right: right };\r\n}\r\nfunction merge(left, right, comparator) {\r\n    if (right === null)\r\n        return left;\r\n    if (left === null)\r\n        return right;\r\n    right = splay(left.key, right, comparator);\r\n    right.left = left;\r\n    return right;\r\n}\r\n/**\r\n * Prints level of the tree\r\n */\r\nfunction printRow(root, prefix, isTail, out, printNode) {\r\n    if (root) {\r\n        out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\r\n        var indent = prefix + (isTail ? '    ' : '│   ');\r\n        if (root.left)\r\n            printRow(root.left, indent, false, out, printNode);\r\n        if (root.right)\r\n            printRow(root.right, indent, true, out, printNode);\r\n    }\r\n}\r\nvar Tree = /** @class */ (function () {\r\n    function Tree(comparator) {\r\n        if (comparator === void 0) { comparator = DEFAULT_COMPARE; }\r\n        this._root = null;\r\n        this._size = 0;\r\n        this._comparator = comparator;\r\n    }\r\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\r\n    Tree.prototype.insert = function (key, data) {\r\n        this._size++;\r\n        return this._root = insert(key, data, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\r\n    Tree.prototype.add = function (key, data) {\r\n        var node = new Node(key, data);\r\n        if (this._root === null) {\r\n            node.left = node.right = null;\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        var comparator = this._comparator;\r\n        var t = splay(key, this._root, comparator);\r\n        var cmp = comparator(key, t.key);\r\n        if (cmp === 0)\r\n            this._root = t;\r\n        else {\r\n            if (cmp < 0) {\r\n                node.left = t.left;\r\n                node.right = t;\r\n                t.left = null;\r\n            }\r\n            else if (cmp > 0) {\r\n                node.right = t.right;\r\n                node.left = t;\r\n                t.right = null;\r\n            }\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        return this._root;\r\n    };\r\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\r\n    Tree.prototype.remove = function (key) {\r\n        this._root = this._remove(key, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\r\n    Tree.prototype._remove = function (i, t, comparator) {\r\n        var x;\r\n        if (t === null)\r\n            return null;\r\n        t = splay(i, t, comparator);\r\n        var cmp = comparator(i, t.key);\r\n        if (cmp === 0) { /* found it */\r\n            if (t.left === null) {\r\n                x = t.right;\r\n            }\r\n            else {\r\n                x = splay(i, t.left, comparator);\r\n                x.right = t.right;\r\n            }\r\n            this._size--;\r\n            return x;\r\n        }\r\n        return t; /* It wasn't there */\r\n    };\r\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\r\n    Tree.prototype.pop = function () {\r\n        var node = this._root;\r\n        if (node) {\r\n            while (node.left)\r\n                node = node.left;\r\n            this._root = splay(node.key, this._root, this._comparator);\r\n            this._root = this._remove(node.key, this._root, this._comparator);\r\n            return { key: node.key, data: node.data };\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Find without splaying\r\n     */\r\n    Tree.prototype.findStatic = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return current;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.find = function (key) {\r\n        if (this._root) {\r\n            this._root = splay(key, this._root, this._comparator);\r\n            if (this._comparator(key, this._root.key) !== 0)\r\n                return null;\r\n        }\r\n        return this._root;\r\n    };\r\n    Tree.prototype.contains = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return true;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return false;\r\n    };\r\n    Tree.prototype.forEach = function (visitor, ctx) {\r\n        var current = this._root;\r\n        var Q = []; /* Initialize stack s */\r\n        var done = false;\r\n        while (!done) {\r\n            if (current !== null) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length !== 0) {\r\n                    current = Q.pop();\r\n                    visitor.call(ctx, current);\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\r\n    Tree.prototype.range = function (low, high, fn, ctx) {\r\n        var Q = [];\r\n        var compare = this._comparator;\r\n        var node = this._root;\r\n        var cmp;\r\n        while (Q.length !== 0 || node) {\r\n            if (node) {\r\n                Q.push(node);\r\n                node = node.left;\r\n            }\r\n            else {\r\n                node = Q.pop();\r\n                cmp = compare(node.key, high);\r\n                if (cmp > 0) {\r\n                    break;\r\n                }\r\n                else if (compare(node.key, low) >= 0) {\r\n                    if (fn.call(ctx, node))\r\n                        return this; // stop if smth is returned\r\n                }\r\n                node = node.right;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns array of keys\r\n     */\r\n    Tree.prototype.keys = function () {\r\n        var keys = [];\r\n        this.forEach(function (_a) {\r\n            var key = _a.key;\r\n            return keys.push(key);\r\n        });\r\n        return keys;\r\n    };\r\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\r\n    Tree.prototype.values = function () {\r\n        var values = [];\r\n        this.forEach(function (_a) {\r\n            var data = _a.data;\r\n            return values.push(data);\r\n        });\r\n        return values;\r\n    };\r\n    Tree.prototype.min = function () {\r\n        if (this._root)\r\n            return this.minNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.max = function () {\r\n        if (this._root)\r\n            return this.maxNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.minNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.left)\r\n                t = t.left;\r\n        return t;\r\n    };\r\n    Tree.prototype.maxNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.right)\r\n                t = t.right;\r\n        return t;\r\n    };\r\n    /**\r\n     * Returns node at given index\r\n     */\r\n    Tree.prototype.at = function (index) {\r\n        var current = this._root;\r\n        var done = false;\r\n        var i = 0;\r\n        var Q = [];\r\n        while (!done) {\r\n            if (current) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length > 0) {\r\n                    current = Q.pop();\r\n                    if (i === index)\r\n                        return current;\r\n                    i++;\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.next = function (d) {\r\n        var root = this._root;\r\n        var successor = null;\r\n        if (d.right) {\r\n            successor = d.right;\r\n            while (successor.left)\r\n                successor = successor.left;\r\n            return successor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0) {\r\n                successor = root;\r\n                root = root.left;\r\n            }\r\n            else\r\n                root = root.right;\r\n        }\r\n        return successor;\r\n    };\r\n    Tree.prototype.prev = function (d) {\r\n        var root = this._root;\r\n        var predecessor = null;\r\n        if (d.left !== null) {\r\n            predecessor = d.left;\r\n            while (predecessor.right)\r\n                predecessor = predecessor.right;\r\n            return predecessor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0)\r\n                root = root.left;\r\n            else {\r\n                predecessor = root;\r\n                root = root.right;\r\n            }\r\n        }\r\n        return predecessor;\r\n    };\r\n    Tree.prototype.clear = function () {\r\n        this._root = null;\r\n        this._size = 0;\r\n        return this;\r\n    };\r\n    Tree.prototype.toList = function () {\r\n        return toList(this._root);\r\n    };\r\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\r\n    Tree.prototype.load = function (keys, values, presort) {\r\n        if (values === void 0) { values = []; }\r\n        if (presort === void 0) { presort = false; }\r\n        var size = keys.length;\r\n        var comparator = this._comparator;\r\n        // sort if needed\r\n        if (presort)\r\n            sort(keys, values, 0, size - 1, comparator);\r\n        if (this._root === null) { // empty tree\r\n            this._root = loadRecursive(keys, values, 0, size);\r\n            this._size = size;\r\n        }\r\n        else { // that re-builds the whole tree from two in-order traversals\r\n            var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n            size = this._size + size;\r\n            this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n        }\r\n        return this;\r\n    };\r\n    Tree.prototype.isEmpty = function () { return this._root === null; };\r\n    Object.defineProperty(Tree.prototype, \"size\", {\r\n        get: function () { return this._size; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tree.prototype, \"root\", {\r\n        get: function () { return this._root; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Tree.prototype.toString = function (printNode) {\r\n        if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }\r\n        var out = [];\r\n        printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);\r\n        return out.join('');\r\n    };\r\n    Tree.prototype.update = function (key, newKey, newData) {\r\n        var comparator = this._comparator;\r\n        var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;\r\n        if (comparator(key, newKey) < 0) {\r\n            right = insert(newKey, newData, right, comparator);\r\n        }\r\n        else {\r\n            left = insert(newKey, newData, left, comparator);\r\n        }\r\n        this._root = merge(left, right, comparator);\r\n    };\r\n    Tree.prototype.split = function (key) {\r\n        return split(key, this._root, this._comparator);\r\n    };\r\n    Tree.prototype[Symbol.iterator] = function () {\r\n        var current, Q, done;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    current = this._root;\r\n                    Q = [];\r\n                    done = false;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!!done) return [3 /*break*/, 6];\r\n                    if (!(current !== null)) return [3 /*break*/, 2];\r\n                    Q.push(current);\r\n                    current = current.left;\r\n                    return [3 /*break*/, 5];\r\n                case 2:\r\n                    if (!(Q.length !== 0)) return [3 /*break*/, 4];\r\n                    current = Q.pop();\r\n                    return [4 /*yield*/, current];\r\n                case 3:\r\n                    _a.sent();\r\n                    current = current.right;\r\n                    return [3 /*break*/, 5];\r\n                case 4:\r\n                    done = true;\r\n                    _a.label = 5;\r\n                case 5: return [3 /*break*/, 1];\r\n                case 6: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return Tree;\r\n}());\r\nfunction loadRecursive(keys, values, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var key = keys[middle];\r\n        var data = values[middle];\r\n        var node = new Node(key, data);\r\n        node.left = loadRecursive(keys, values, start, middle);\r\n        node.right = loadRecursive(keys, values, middle + 1, end);\r\n        return node;\r\n    }\r\n    return null;\r\n}\r\nfunction createList(keys, values) {\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    for (var i = 0; i < keys.length; i++) {\r\n        p = p.next = new Node(keys[i], values[i]);\r\n    }\r\n    p.next = null;\r\n    return head.next;\r\n}\r\nfunction toList(root) {\r\n    var current = root;\r\n    var Q = [];\r\n    var done = false;\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    while (!done) {\r\n        if (current) {\r\n            Q.push(current);\r\n            current = current.left;\r\n        }\r\n        else {\r\n            if (Q.length > 0) {\r\n                current = p = p.next = Q.pop();\r\n                current = current.right;\r\n            }\r\n            else\r\n                done = true;\r\n        }\r\n    }\r\n    p.next = null; // that'll work even if the tree was empty\r\n    return head.next;\r\n}\r\nfunction sortedListToBST(list, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var left = sortedListToBST(list, start, middle);\r\n        var root = list.head;\r\n        root.left = left;\r\n        list.head = list.head.next;\r\n        root.right = sortedListToBST(list, middle + 1, end);\r\n        return root;\r\n    }\r\n    return null;\r\n}\r\nfunction mergeLists(l1, l2, compare) {\r\n    var head = new Node(null, null); // dummy\r\n    var p = head;\r\n    var p1 = l1;\r\n    var p2 = l2;\r\n    while (p1 !== null && p2 !== null) {\r\n        if (compare(p1.key, p2.key) < 0) {\r\n            p.next = p1;\r\n            p1 = p1.next;\r\n        }\r\n        else {\r\n            p.next = p2;\r\n            p2 = p2.next;\r\n        }\r\n        p = p.next;\r\n    }\r\n    if (p1 !== null) {\r\n        p.next = p1;\r\n    }\r\n    else if (p2 !== null) {\r\n        p.next = p2;\r\n    }\r\n    return head.next;\r\n}\r\nfunction sort(keys, values, left, right, compare) {\r\n    if (left >= right)\r\n        return;\r\n    var pivot = keys[(left + right) >> 1];\r\n    var i = left - 1;\r\n    var j = right + 1;\r\n    while (true) {\r\n        do\r\n            i++;\r\n        while (compare(keys[i], pivot) < 0);\r\n        do\r\n            j--;\r\n        while (compare(keys[j], pivot) > 0);\r\n        if (i >= j)\r\n            break;\r\n        var tmp = keys[i];\r\n        keys[i] = keys[j];\r\n        keys[j] = tmp;\r\n        tmp = values[i];\r\n        values[i] = values[j];\r\n        values[j] = tmp;\r\n    }\r\n    sort(keys, values, left, j, compare);\r\n    sort(keys, values, j + 1, right, compare);\r\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tree);\n//# sourceMappingURL=splay.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3BsYXl0cmVlL2Rpc3Qvc3BsYXkuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsMkNBQTJDLGtCQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9EO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxJQUFJLEVBQUM7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ib3VuZGFyeS1kZWxpbmVhdGlvbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvc3BsYXl0cmVlL2Rpc3Qvc3BsYXkuZXNtLmpzPzljYTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBzcGxheXRyZWUgdjMuMS4yXG4gKiBGYXN0IFNwbGF5IHRyZWUgZm9yIE5vZGUgYW5kIGJyb3dzZXJcbiAqXG4gKiBAYXV0aG9yIEFsZXhhbmRlciBNaWxldnNraSA8aW5mb0B3OHIubmFtZT5cbiAqIEBsaWNlbnNlIE1JVFxuICogQHByZXNlcnZlXG4gKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XG5cbnZhciBOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9kZShrZXksIGRhdGEpIHtcclxuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBOb2RlO1xyXG59KCkpO1xuXG4vKiBmb2xsb3dzIFwiQW4gaW1wbGVtZW50YXRpb24gb2YgdG9wLWRvd24gc3BsYXlpbmdcIlxyXG4gKiBieSBELiBTbGVhdG9yIDxzbGVhdG9yQGNzLmNtdS5lZHU+IE1hcmNoIDE5OTJcclxuICovXHJcbmZ1bmN0aW9uIERFRkFVTFRfQ09NUEFSRShhLCBiKSB7XHJcbiAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XHJcbn1cclxuLyoqXHJcbiAqIFNpbXBsZSB0b3AgZG93biBzcGxheSwgbm90IHJlcXVpcmluZyBpIHRvIGJlIGluIHRoZSB0cmVlIHQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGxheShpLCB0LCBjb21wYXJhdG9yKSB7XHJcbiAgICB2YXIgTiA9IG5ldyBOb2RlKG51bGwsIG51bGwpO1xyXG4gICAgdmFyIGwgPSBOO1xyXG4gICAgdmFyIHIgPSBOO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgY21wID0gY29tcGFyYXRvcihpLCB0LmtleSk7XHJcbiAgICAgICAgLy9pZiAoaSA8IHQua2V5KSB7XHJcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgaWYgKHQubGVmdCA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvL2lmIChpIDwgdC5sZWZ0LmtleSkge1xyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihpLCB0LmxlZnQua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gdC5sZWZ0OyAvKiByb3RhdGUgcmlnaHQgKi9cclxuICAgICAgICAgICAgICAgIHQubGVmdCA9IHkucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB5LnJpZ2h0ID0gdDtcclxuICAgICAgICAgICAgICAgIHQgPSB5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHQubGVmdCA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByLmxlZnQgPSB0OyAvKiBsaW5rIHJpZ2h0ICovXHJcbiAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICB0ID0gdC5sZWZ0O1xyXG4gICAgICAgICAgICAvL30gZWxzZSBpZiAoaSA+IHQua2V5KSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHQucmlnaHQgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgLy9pZiAoaSA+IHQucmlnaHQua2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGksIHQucmlnaHQua2V5KSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gdC5yaWdodDsgLyogcm90YXRlIGxlZnQgKi9cclxuICAgICAgICAgICAgICAgIHQucmlnaHQgPSB5LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB5LmxlZnQgPSB0O1xyXG4gICAgICAgICAgICAgICAgdCA9IHk7XHJcbiAgICAgICAgICAgICAgICBpZiAodC5yaWdodCA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsLnJpZ2h0ID0gdDsgLyogbGluayBsZWZ0ICovXHJcbiAgICAgICAgICAgIGwgPSB0O1xyXG4gICAgICAgICAgICB0ID0gdC5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIC8qIGFzc2VtYmxlICovXHJcbiAgICBsLnJpZ2h0ID0gdC5sZWZ0O1xyXG4gICAgci5sZWZ0ID0gdC5yaWdodDtcclxuICAgIHQubGVmdCA9IE4ucmlnaHQ7XHJcbiAgICB0LnJpZ2h0ID0gTi5sZWZ0O1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuZnVuY3Rpb24gaW5zZXJ0KGksIGRhdGEsIHQsIGNvbXBhcmF0b3IpIHtcclxuICAgIHZhciBub2RlID0gbmV3IE5vZGUoaSwgZGF0YSk7XHJcbiAgICBpZiAodCA9PT0gbnVsbCkge1xyXG4gICAgICAgIG5vZGUubGVmdCA9IG5vZGUucmlnaHQgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgdCA9IHNwbGF5KGksIHQsIGNvbXBhcmF0b3IpO1xyXG4gICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xyXG4gICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICBub2RlLmxlZnQgPSB0LmxlZnQ7XHJcbiAgICAgICAgbm9kZS5yaWdodCA9IHQ7XHJcbiAgICAgICAgdC5sZWZ0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNtcCA+PSAwKSB7XHJcbiAgICAgICAgbm9kZS5yaWdodCA9IHQucmlnaHQ7XHJcbiAgICAgICAgbm9kZS5sZWZ0ID0gdDtcclxuICAgICAgICB0LnJpZ2h0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBub2RlO1xyXG59XHJcbmZ1bmN0aW9uIHNwbGl0KGtleSwgdiwgY29tcGFyYXRvcikge1xyXG4gICAgdmFyIGxlZnQgPSBudWxsO1xyXG4gICAgdmFyIHJpZ2h0ID0gbnVsbDtcclxuICAgIGlmICh2KSB7XHJcbiAgICAgICAgdiA9IHNwbGF5KGtleSwgdiwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3Iodi5rZXksIGtleSk7XHJcbiAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gdi5sZWZ0O1xyXG4gICAgICAgICAgICByaWdodCA9IHYucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgcmlnaHQgPSB2LnJpZ2h0O1xyXG4gICAgICAgICAgICB2LnJpZ2h0ID0gbnVsbDtcclxuICAgICAgICAgICAgbGVmdCA9IHY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0ID0gdi5sZWZ0O1xyXG4gICAgICAgICAgICB2LmxlZnQgPSBudWxsO1xyXG4gICAgICAgICAgICByaWdodCA9IHY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCwgcmlnaHQ6IHJpZ2h0IH07XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2UobGVmdCwgcmlnaHQsIGNvbXBhcmF0b3IpIHtcclxuICAgIGlmIChyaWdodCA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gbGVmdDtcclxuICAgIGlmIChsZWZ0ID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiByaWdodDtcclxuICAgIHJpZ2h0ID0gc3BsYXkobGVmdC5rZXksIHJpZ2h0LCBjb21wYXJhdG9yKTtcclxuICAgIHJpZ2h0LmxlZnQgPSBsZWZ0O1xyXG4gICAgcmV0dXJuIHJpZ2h0O1xyXG59XHJcbi8qKlxyXG4gKiBQcmludHMgbGV2ZWwgb2YgdGhlIHRyZWVcclxuICovXHJcbmZ1bmN0aW9uIHByaW50Um93KHJvb3QsIHByZWZpeCwgaXNUYWlsLCBvdXQsIHByaW50Tm9kZSkge1xyXG4gICAgaWYgKHJvb3QpIHtcclxuICAgICAgICBvdXQoXCJcIiArIHByZWZpeCArIChpc1RhaWwgPyAn4pSU4pSA4pSAICcgOiAn4pSc4pSA4pSAICcpICsgcHJpbnROb2RlKHJvb3QpICsgXCJcXG5cIik7XHJcbiAgICAgICAgdmFyIGluZGVudCA9IHByZWZpeCArIChpc1RhaWwgPyAnICAgICcgOiAn4pSCICAgJyk7XHJcbiAgICAgICAgaWYgKHJvb3QubGVmdClcclxuICAgICAgICAgICAgcHJpbnRSb3cocm9vdC5sZWZ0LCBpbmRlbnQsIGZhbHNlLCBvdXQsIHByaW50Tm9kZSk7XHJcbiAgICAgICAgaWYgKHJvb3QucmlnaHQpXHJcbiAgICAgICAgICAgIHByaW50Um93KHJvb3QucmlnaHQsIGluZGVudCwgdHJ1ZSwgb3V0LCBwcmludE5vZGUpO1xyXG4gICAgfVxyXG59XHJcbnZhciBUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVHJlZShjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IgPT09IHZvaWQgMCkgeyBjb21wYXJhdG9yID0gREVGQVVMVF9DT01QQVJFOyB9XHJcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYSBrZXksIGFsbG93cyBkdXBsaWNhdGVzXHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIGRhdGEpIHtcclxuICAgICAgICB0aGlzLl9zaXplKys7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QgPSBpbnNlcnQoa2V5LCBkYXRhLCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBrZXksIGlmIGl0IGlzIG5vdCBwcmVzZW50IGluIHRoZSB0cmVlXHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChrZXksIGRhdGEpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKGtleSwgZGF0YSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgbm9kZS5sZWZ0ID0gbm9kZS5yaWdodCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemUrKztcclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICB2YXIgdCA9IHNwbGF5KGtleSwgdGhpcy5fcm9vdCwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3Ioa2V5LCB0LmtleSk7XHJcbiAgICAgICAgaWYgKGNtcCA9PT0gMClcclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHQ7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxlZnQgPSB0LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICBub2RlLnJpZ2h0ID0gdDtcclxuICAgICAgICAgICAgICAgIHQubGVmdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5yaWdodCA9IHQucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxlZnQgPSB0O1xyXG4gICAgICAgICAgICAgICAgdC5yaWdodCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gIHtLZXl9IGtleVxyXG4gICAgICogQHJldHVybiB7Tm9kZXxudWxsfVxyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX3JlbW92ZShrZXksIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBpIGZyb20gdGhlIHRyZWUgaWYgaXQncyB0aGVyZVxyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKGksIHQsIGNvbXBhcmF0b3IpIHtcclxuICAgICAgICB2YXIgeDtcclxuICAgICAgICBpZiAodCA9PT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgdCA9IHNwbGF5KGksIHQsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGksIHQua2V5KTtcclxuICAgICAgICBpZiAoY21wID09PSAwKSB7IC8qIGZvdW5kIGl0ICovXHJcbiAgICAgICAgICAgIGlmICh0LmxlZnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHggPSB0LnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeCA9IHNwbGF5KGksIHQubGVmdCwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICB4LnJpZ2h0ID0gdC5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zaXplLS07XHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDsgLyogSXQgd2Fzbid0IHRoZXJlICovXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSBub2RlIHdpdGggc21hbGxlc3Qga2V5XHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgd2hpbGUgKG5vZGUubGVmdClcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBzcGxheShub2RlLmtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLl9yZW1vdmUobm9kZS5rZXksIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IG5vZGUua2V5LCBkYXRhOiBub2RlLmRhdGEgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHdpdGhvdXQgc3BsYXlpbmdcclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUuZmluZFN0YXRpYyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBjbXAgPSBjb21wYXJlKGtleSwgY3VycmVudC5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoY21wID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gc3BsYXkoa2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbXBhcmF0b3Ioa2V5LCB0aGlzLl9yb290LmtleSkgIT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIHZhciBjb21wYXJlID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICB2YXIgY21wID0gY29tcGFyZShrZXksIGN1cnJlbnQua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKHZpc2l0b3IsIGN0eCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcclxuICAgICAgICB2YXIgUSA9IFtdOyAvKiBJbml0aWFsaXplIHN0YWNrIHMgKi9cclxuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgIHdoaWxlICghZG9uZSkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgUS5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChRLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBRLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpc2l0b3IuY2FsbChjdHgsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2FsayBrZXkgcmFuZ2UgZnJvbSBgbG93YCB0byBgaGlnaGAuIFN0b3BzIGlmIGBmbmAgcmV0dXJucyBhIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChsb3csIGhpZ2gsIGZuLCBjdHgpIHtcclxuICAgICAgICB2YXIgUSA9IFtdO1xyXG4gICAgICAgIHZhciBjb21wYXJlID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgdmFyIGNtcDtcclxuICAgICAgICB3aGlsZSAoUS5sZW5ndGggIT09IDAgfHwgbm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgUS5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBRLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgY21wID0gY29tcGFyZShub2RlLmtleSwgaGlnaCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY21wID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyZShub2RlLmtleSwgbG93KSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZuLmNhbGwoY3R4LCBub2RlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIHN0b3AgaWYgc210aCBpcyByZXR1cm5lZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFycmF5IG9mIGtleXNcclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IF9hLmtleTtcclxuICAgICAgICAgICAgcmV0dXJuIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhcnJheSBvZiBhbGwgdGhlIGRhdGEgaW4gdGhlIG5vZGVzXHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IF9hLmRhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMucHVzaChkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluTm9kZSh0aGlzLl9yb290KS5rZXk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhOb2RlKHRoaXMuX3Jvb3QpLmtleTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS5taW5Ob2RlID0gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBpZiAodCA9PT0gdm9pZCAwKSB7IHQgPSB0aGlzLl9yb290OyB9XHJcbiAgICAgICAgaWYgKHQpXHJcbiAgICAgICAgICAgIHdoaWxlICh0LmxlZnQpXHJcbiAgICAgICAgICAgICAgICB0ID0gdC5sZWZ0O1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLm1heE5vZGUgPSBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGlmICh0ID09PSB2b2lkIDApIHsgdCA9IHRoaXMuX3Jvb3Q7IH1cclxuICAgICAgICBpZiAodClcclxuICAgICAgICAgICAgd2hpbGUgKHQucmlnaHQpXHJcbiAgICAgICAgICAgICAgICB0ID0gdC5yaWdodDtcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbm9kZSBhdCBnaXZlbiBpbmRleFxyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcclxuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB2YXIgUSA9IFtdO1xyXG4gICAgICAgIHdoaWxlICghZG9uZSkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgUS5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChRLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gUS5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgdmFyIHN1Y2Nlc3NvciA9IG51bGw7XHJcbiAgICAgICAgaWYgKGQucmlnaHQpIHtcclxuICAgICAgICAgICAgc3VjY2Vzc29yID0gZC5yaWdodDtcclxuICAgICAgICAgICAgd2hpbGUgKHN1Y2Nlc3Nvci5sZWZ0KVxyXG4gICAgICAgICAgICAgICAgc3VjY2Vzc29yID0gc3VjY2Vzc29yLmxlZnQ7XHJcbiAgICAgICAgICAgIHJldHVybiBzdWNjZXNzb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICB3aGlsZSAocm9vdCkge1xyXG4gICAgICAgICAgICB2YXIgY21wID0gY29tcGFyYXRvcihkLmtleSwgcm9vdC5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoY21wID09PSAwKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NvciA9IHJvb3Q7XHJcbiAgICAgICAgICAgICAgICByb290ID0gcm9vdC5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJvb3QgPSByb290LnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VjY2Vzc29yO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcclxuICAgICAgICB2YXIgcHJlZGVjZXNzb3IgPSBudWxsO1xyXG4gICAgICAgIGlmIChkLmxlZnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJlZGVjZXNzb3IgPSBkLmxlZnQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChwcmVkZWNlc3Nvci5yaWdodClcclxuICAgICAgICAgICAgICAgIHByZWRlY2Vzc29yID0gcHJlZGVjZXNzb3IucmlnaHQ7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmVkZWNlc3NvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgIHdoaWxlIChyb290KSB7XHJcbiAgICAgICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGQua2V5LCByb290LmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMClcclxuICAgICAgICAgICAgICAgIHJvb3QgPSByb290LmxlZnQ7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJlZGVjZXNzb3IgPSByb290O1xyXG4gICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByZWRlY2Vzc29yO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLnRvTGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdG9MaXN0KHRoaXMuX3Jvb3QpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQnVsay1sb2FkIGl0ZW1zLiBCb3RoIGFycmF5IGhhdmUgdG8gYmUgc2FtZSBzaXplXHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoa2V5cywgdmFsdWVzLCBwcmVzb3J0KSB7XHJcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IFtdOyB9XHJcbiAgICAgICAgaWYgKHByZXNvcnQgPT09IHZvaWQgMCkgeyBwcmVzb3J0ID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgc2l6ZSA9IGtleXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICAvLyBzb3J0IGlmIG5lZWRlZFxyXG4gICAgICAgIGlmIChwcmVzb3J0KVxyXG4gICAgICAgICAgICBzb3J0KGtleXMsIHZhbHVlcywgMCwgc2l6ZSAtIDEsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290ID09PSBudWxsKSB7IC8vIGVtcHR5IHRyZWVcclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IGxvYWRSZWN1cnNpdmUoa2V5cywgdmFsdWVzLCAwLCBzaXplKTtcclxuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgeyAvLyB0aGF0IHJlLWJ1aWxkcyB0aGUgd2hvbGUgdHJlZSBmcm9tIHR3byBpbi1vcmRlciB0cmF2ZXJzYWxzXHJcbiAgICAgICAgICAgIHZhciBtZXJnZWRMaXN0ID0gbWVyZ2VMaXN0cyh0aGlzLnRvTGlzdCgpLCBjcmVhdGVMaXN0KGtleXMsIHZhbHVlcyksIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICBzaXplID0gdGhpcy5fc2l6ZSArIHNpemU7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBzb3J0ZWRMaXN0VG9CU1QoeyBoZWFkOiBtZXJnZWRMaXN0IH0sIDAsIHNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm9vdCA9PT0gbnVsbDsgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmVlLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NpemU7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyZWUucHJvdG90eXBlLCBcInJvb3RcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm9vdDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBUcmVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChwcmludE5vZGUpIHtcclxuICAgICAgICBpZiAocHJpbnROb2RlID09PSB2b2lkIDApIHsgcHJpbnROb2RlID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFN0cmluZyhuLmtleSk7IH07IH1cclxuICAgICAgICB2YXIgb3V0ID0gW107XHJcbiAgICAgICAgcHJpbnRSb3codGhpcy5fcm9vdCwgJycsIHRydWUsIGZ1bmN0aW9uICh2KSB7IHJldHVybiBvdXQucHVzaCh2KTsgfSwgcHJpbnROb2RlKTtcclxuICAgICAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChrZXksIG5ld0tleSwgbmV3RGF0YSkge1xyXG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICB2YXIgX2EgPSBzcGxpdChrZXksIHRoaXMuX3Jvb3QsIGNvbXBhcmF0b3IpLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodDtcclxuICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG5ld0tleSkgPCAwKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gaW5zZXJ0KG5ld0tleSwgbmV3RGF0YSwgcmlnaHQsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVmdCA9IGluc2VydChuZXdLZXksIG5ld0RhdGEsIGxlZnQsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yb290ID0gbWVyZ2UobGVmdCwgcmlnaHQsIGNvbXBhcmF0b3IpO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiBzcGxpdChrZXksIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IpO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQsIFEsIGRvbmU7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgUSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhZG9uZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoY3VycmVudCAhPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIFEucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKFEubGVuZ3RoICE9PSAwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY3VycmVudF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUcmVlO1xyXG59KCkpO1xyXG5mdW5jdGlvbiBsb2FkUmVjdXJzaXZlKGtleXMsIHZhbHVlcywgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHNpemUgPSBlbmQgLSBzdGFydDtcclxuICAgIGlmIChzaXplID4gMCkge1xyXG4gICAgICAgIHZhciBtaWRkbGUgPSBzdGFydCArIE1hdGguZmxvb3Ioc2l6ZSAvIDIpO1xyXG4gICAgICAgIHZhciBrZXkgPSBrZXlzW21pZGRsZV07XHJcbiAgICAgICAgdmFyIGRhdGEgPSB2YWx1ZXNbbWlkZGxlXTtcclxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKGtleSwgZGF0YSk7XHJcbiAgICAgICAgbm9kZS5sZWZ0ID0gbG9hZFJlY3Vyc2l2ZShrZXlzLCB2YWx1ZXMsIHN0YXJ0LCBtaWRkbGUpO1xyXG4gICAgICAgIG5vZGUucmlnaHQgPSBsb2FkUmVjdXJzaXZlKGtleXMsIHZhbHVlcywgbWlkZGxlICsgMSwgZW5kKTtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUxpc3Qoa2V5cywgdmFsdWVzKSB7XHJcbiAgICB2YXIgaGVhZCA9IG5ldyBOb2RlKG51bGwsIG51bGwpO1xyXG4gICAgdmFyIHAgPSBoZWFkO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcCA9IHAubmV4dCA9IG5ldyBOb2RlKGtleXNbaV0sIHZhbHVlc1tpXSk7XHJcbiAgICB9XHJcbiAgICBwLm5leHQgPSBudWxsO1xyXG4gICAgcmV0dXJuIGhlYWQubmV4dDtcclxufVxyXG5mdW5jdGlvbiB0b0xpc3Qocm9vdCkge1xyXG4gICAgdmFyIGN1cnJlbnQgPSByb290O1xyXG4gICAgdmFyIFEgPSBbXTtcclxuICAgIHZhciBkb25lID0gZmFsc2U7XHJcbiAgICB2YXIgaGVhZCA9IG5ldyBOb2RlKG51bGwsIG51bGwpO1xyXG4gICAgdmFyIHAgPSBoZWFkO1xyXG4gICAgd2hpbGUgKCFkb25lKSB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgUS5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKFEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHAgPSBwLm5leHQgPSBRLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcC5uZXh0ID0gbnVsbDsgLy8gdGhhdCdsbCB3b3JrIGV2ZW4gaWYgdGhlIHRyZWUgd2FzIGVtcHR5XHJcbiAgICByZXR1cm4gaGVhZC5uZXh0O1xyXG59XHJcbmZ1bmN0aW9uIHNvcnRlZExpc3RUb0JTVChsaXN0LCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgc2l6ZSA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgaWYgKHNpemUgPiAwKSB7XHJcbiAgICAgICAgdmFyIG1pZGRsZSA9IHN0YXJ0ICsgTWF0aC5mbG9vcihzaXplIC8gMik7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBzb3J0ZWRMaXN0VG9CU1QobGlzdCwgc3RhcnQsIG1pZGRsZSk7XHJcbiAgICAgICAgdmFyIHJvb3QgPSBsaXN0LmhlYWQ7XHJcbiAgICAgICAgcm9vdC5sZWZ0ID0gbGVmdDtcclxuICAgICAgICBsaXN0LmhlYWQgPSBsaXN0LmhlYWQubmV4dDtcclxuICAgICAgICByb290LnJpZ2h0ID0gc29ydGVkTGlzdFRvQlNUKGxpc3QsIG1pZGRsZSArIDEsIGVuZCk7XHJcbiAgICAgICAgcmV0dXJuIHJvb3Q7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUxpc3RzKGwxLCBsMiwgY29tcGFyZSkge1xyXG4gICAgdmFyIGhlYWQgPSBuZXcgTm9kZShudWxsLCBudWxsKTsgLy8gZHVtbXlcclxuICAgIHZhciBwID0gaGVhZDtcclxuICAgIHZhciBwMSA9IGwxO1xyXG4gICAgdmFyIHAyID0gbDI7XHJcbiAgICB3aGlsZSAocDEgIT09IG51bGwgJiYgcDIgIT09IG51bGwpIHtcclxuICAgICAgICBpZiAoY29tcGFyZShwMS5rZXksIHAyLmtleSkgPCAwKSB7XHJcbiAgICAgICAgICAgIHAubmV4dCA9IHAxO1xyXG4gICAgICAgICAgICBwMSA9IHAxLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwLm5leHQgPSBwMjtcclxuICAgICAgICAgICAgcDIgPSBwMi5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgfVxyXG4gICAgaWYgKHAxICE9PSBudWxsKSB7XHJcbiAgICAgICAgcC5uZXh0ID0gcDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwMiAhPT0gbnVsbCkge1xyXG4gICAgICAgIHAubmV4dCA9IHAyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhlYWQubmV4dDtcclxufVxyXG5mdW5jdGlvbiBzb3J0KGtleXMsIHZhbHVlcywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcclxuICAgIGlmIChsZWZ0ID49IHJpZ2h0KVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciBwaXZvdCA9IGtleXNbKGxlZnQgKyByaWdodCkgPj4gMV07XHJcbiAgICB2YXIgaSA9IGxlZnQgLSAxO1xyXG4gICAgdmFyIGogPSByaWdodCArIDE7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGRvXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB3aGlsZSAoY29tcGFyZShrZXlzW2ldLCBwaXZvdCkgPCAwKTtcclxuICAgICAgICBkb1xyXG4gICAgICAgICAgICBqLS07XHJcbiAgICAgICAgd2hpbGUgKGNvbXBhcmUoa2V5c1tqXSwgcGl2b3QpID4gMCk7XHJcbiAgICAgICAgaWYgKGkgPj0gailcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgdmFyIHRtcCA9IGtleXNbaV07XHJcbiAgICAgICAga2V5c1tpXSA9IGtleXNbal07XHJcbiAgICAgICAga2V5c1tqXSA9IHRtcDtcclxuICAgICAgICB0bXAgPSB2YWx1ZXNbaV07XHJcbiAgICAgICAgdmFsdWVzW2ldID0gdmFsdWVzW2pdO1xyXG4gICAgICAgIHZhbHVlc1tqXSA9IHRtcDtcclxuICAgIH1cclxuICAgIHNvcnQoa2V5cywgdmFsdWVzLCBsZWZ0LCBqLCBjb21wYXJlKTtcclxuICAgIHNvcnQoa2V5cywgdmFsdWVzLCBqICsgMSwgcmlnaHQsIGNvbXBhcmUpO1xyXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyZWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGxheS5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/splaytree/dist/splay.esm.js\n");

/***/ })

};
;